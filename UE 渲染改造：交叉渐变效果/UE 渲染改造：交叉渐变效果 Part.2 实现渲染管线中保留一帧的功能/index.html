<!DOCTYPE html>
<html lang='cn'>

<head>
  <meta name="generator" content="Hexo 5.4.1">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>UE 渲染改造：交叉渐变效果 Part.2 实现渲染管线中保留一帧的功能 - malos-blog</title>

  
    <meta name="description" content="UE 渲染改造：交叉渐变效果&lt;&lt; Part.1 前言 Part.2 实现渲染管线中保留一帧的功能 将会涉及到的概念：  UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer。 UE 中 RDG、FRDGTexture、FPooledRenderTarget 的理解和使用。 UE 中后">
<meta property="og:type" content="article">
<meta property="og:title" content="UE 渲染改造：交叉渐变效果 Part.2 实现渲染管线中保留一帧的功能">
<meta property="og:url" content="https://gavinkg.github.io/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E4%BF%9D%E7%95%99%E4%B8%80%E5%B8%A7%E7%9A%84%E5%8A%9F%E8%83%BD/index.html">
<meta property="og:site_name" content="malos-blog">
<meta property="og:description" content="UE 渲染改造：交叉渐变效果&lt;&lt; Part.1 前言 Part.2 实现渲染管线中保留一帧的功能 将会涉及到的概念：  UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer。 UE 中 RDG、FRDGTexture、FPooledRenderTarget 的理解和使用。 UE 中后">
<meta property="og:locale">
<meta property="og:image" content="https://gavinkg.github.io/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E4%BF%9D%E7%95%99%E4%B8%80%E5%B8%A7%E7%9A%84%E5%8A%9F%E8%83%BD/VisPool.png">
<meta property="article:published_time" content="2022-03-19T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-21T13:52:34.737Z">
<meta property="article:author" content="Gavin_KG">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gavinkg.github.io/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E4%BF%9D%E7%95%99%E4%B8%80%E5%B8%A7%E7%9A%84%E5%8A%9F%E8%83%BD/VisPool.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/blog/atom.xml" title="malos-blog" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/blog/css/main.css">

  

  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/blog/"><div class="main">malos-blog</div><div class="sub cap">subtitle</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/blog/">博客</a><a class="nav-item" href="/blog/about/">关于</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-2-%E5%AE%9E%E7%8E%B0%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E4%BF%9D%E7%95%99%E4%B8%80%E5%B8%A7%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">Part.2 实现渲染管线中保留一帧的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-ViewState-%E4%B8%AD%E5%AD%98%E6%94%BE%E4%BF%9D%E7%95%99%E5%B8%A7%E5%AF%B9%E8%B1%A1"><span class="toc-text">在 ViewState 中存放保留帧对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Tonemapping-%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%88%AA%E5%8F%96%E9%80%BB%E8%BE%91"><span class="toc-text">在 Tonemapping 后添加截取逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-RDG-%E4%B8%AD%E6%88%AA%E5%8F%96%E4%B8%80%E5%B8%A7"><span class="toc-text">从 RDG 中截取一帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Debug%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-text">Debug（可选）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CVar-%E6%B1%87%E6%80%BB"><span class="toc-text">CVar 汇总</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol></li></ol></div></div></div>


</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" title="GitHub" href="https://github.com/GavinKG" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/08a41b181ce68.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/blog/">malos-blog</a><span class="sep"></span><a class="cap breadcrumb" href="/blog/">文章</a></div><div id="post-meta">发布于&nbsp;<time datetime="2022-03-19T16:00:00.000Z">2022-03-20</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>UE 渲染改造：交叉渐变效果 Part.2 实现渲染管线中保留一帧的功能</span></h1>
<h1 id="UE-渲染改造：交叉渐变效果"><a href="#UE-渲染改造：交叉渐变效果" class="headerlink" title="UE 渲染改造：交叉渐变效果"></a>UE 渲染改造：交叉渐变效果</h1><p><a href="">&lt;&lt; Part.1 前言</a></p>
<h2 id="Part-2-实现渲染管线中保留一帧的功能"><a href="#Part-2-实现渲染管线中保留一帧的功能" class="headerlink" title="Part.2 实现渲染管线中保留一帧的功能"></a>Part.2 实现渲染管线中保留一帧的功能</h2><blockquote>
<p>将会涉及到的概念：</p>
<ul>
<li>UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer。</li>
<li>UE 中 RDG、FRDGTexture、FPooledRenderTarget 的理解和使用。</li>
<li>UE 中后处理（Screen Pass）堆栈，如何增加一个自定义 Pass，如何处理“最后一个 Pass”的逻辑。</li>
</ul>
<p>将会更改的引擎源文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主要逻辑：</span><br><span class="line">+ Engine/Source/Runtime/Renderer/Public/PersistentSceneTexture.h</span><br><span class="line">+ Engine/Source/Runtime/Renderer/Private/PersistentSceneTexture.cpp</span><br><span class="line"></span><br><span class="line">将保留帧植入 ViewStates：</span><br><span class="line">* Engine/Source/Runtime/Renderer/Private/ScenePrivate.h</span><br><span class="line"></span><br><span class="line">绘制 Debug：</span><br><span class="line">* Engine/Source/Runtime/Renderer/Private/SceneRendering.cpp</span><br><span class="line"></span><br><span class="line">保留帧截取发生地：</span><br><span class="line">* Engine/Source/Runtime/Renderer/Private/PostProcess/PostProcessing.cpp</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们的思路很简单：找到渲染管线的一个节点，让这个节点渲染出来的图被拷贝到一个新图上，然后存在特定的位置，供后处理材质读取（将在 Part.3 提到）。于是我们得到两个问题：<strong>存在哪个位置？在哪里截取？</strong></p>
<h3 id="在-ViewState-中存放保留帧对象"><a href="#在-ViewState-中存放保留帧对象" class="headerlink" title="在 ViewState 中存放保留帧对象"></a>在 ViewState 中存放保留帧对象</h3><blockquote>
<p>为了不破坏篇幅结构，关于 UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer 的梳理将会另起一片文章来写：<a href="">UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer</a></p>
</blockquote>
<p>由于 ViewState 对象横跨多帧存在，同时我们需要给可能存在的每一个 View 都进行“截图”操作，<strong>因此将保留帧对象，即保留下来的那张图的指针存放在 ViewState 里再合适不过了</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FSceneViewState</span> : <span class="keyword">public</span> FSceneViewStateInterface, <span class="keyword">public</span> FRenderResource</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    FPersistentSceneTextureHolder PersistentSceneTextureHolder;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <em>FPersistentSceneTextureHolder</em> 即承载了包含截图纹理的指针的用处，其实现如下（这里为了节省篇幅，直接上全部声明）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FPersistentSceneTextureHolder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将该Holder注册/移除全局管理器“FPersistentSceneTextureManager”</span></span><br><span class="line">	<span class="built_in">FPersistentSceneTextureHolder</span>();</span><br><span class="line">	~<span class="built_in">FPersistentSceneTextureHolder</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 由于该类归属于ViewState，为了保险起见，禁用拷贝</span></span><br><span class="line">	<span class="built_in">FPersistentSceneTextureHolder</span>(<span class="type">const</span> FPersistentSceneTextureHolder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	FPersistentSceneTextureHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> FPersistentSceneTextureHolder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前View的保留帧/释放保留帧实现</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PreserveCurrent</span><span class="params">()</span> </span>&#123; bShouldPreserveCurrent = <span class="literal">true</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReleasePreserved</span><span class="params">()</span> </span>&#123; PreservedSceneTexture.<span class="built_in">SafeRelease</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取保留帧Pass和Debug Pass的实现</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddPreservePass</span><span class="params">(FRDGBuilder&amp; GraphBuilder, <span class="type">const</span> FViewInfo&amp; View, <span class="type">const</span> <span class="keyword">struct</span> FScreenPassTexture&amp; SourceTexture)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddDebugPass</span><span class="params">(FRDGBuilder&amp; GraphBuilder, <span class="type">const</span> FViewInfo&amp; View, <span class="type">const</span> <span class="keyword">struct</span> FScreenPassRenderTarget&amp; Output)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保留帧指针和保留触发标记</span></span><br><span class="line">	TRefCountPtr&lt;IPooledRenderTarget&gt; PreservedSceneTexture;</span><br><span class="line">	<span class="type">bool</span> bShouldPreserveCurrent = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体主要需要完成以下几个工作：</p>
<ul>
<li><p><strong>构造时将自己注册到一个全局的Holder列表中，析构时再把自己从Holder列表中移除。</strong>设计这个全局列表主要是<strong>方便截帧的命令下达</strong>。我们当然可以遍历所有可能出现的 <em>ULocalPlayer</em> 或者是 <em>FEditorViewportClient</em>，从中找到 ViewState，然后下达命令，但制作一个全局的列表，再构造/析构中动态注册/接触注册的设计思路能够让截帧命令下达逻辑更清晰——直接遍历全局数组即可。</p>
<p>让我们看一下实现吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** PersistentSceneTexture.h **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 盛放全局Holders列表的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPersistentSceneTextureManager</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">FPersistentSceneTextureHolder</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态截帧/释放方法。可以在任何线程上调用</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PreserveCurrent</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ReleasePreserved</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 归属于渲染线程，用于存储所有Holders。其定义在 PersistentSceneTexture.cpp 中。</span></span><br><span class="line">	<span class="type">static</span> TSet&lt;FPersistentSceneTextureHolder*&gt; Holders;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** PersistentSceneTexture.cpp **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局截帧方法。操作将在渲染线程完成。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPersistentSceneTextureManager::PreserveCurrent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ENQUEUE_RENDER_COMMAND</span>(PreserveSceneTexture)([](FRHICommandListImmediate&amp;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (FPersistentSceneTextureHolder* Holder : Holders)</span><br><span class="line">		&#123;</span><br><span class="line">			Holder-&gt;<span class="built_in">PreserveCurrent</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogPersistentSceneTexture, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Marking %d holder(s) to preserve...&quot;</span>), Holders.<span class="built_in">Num</span>());</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局释放方法。操作将在渲染线程完成。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPersistentSceneTextureManager::ReleasePreserved</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ENQUEUE_RENDER_COMMAND</span>(PreserveSceneTexture)([](FRHICommandListImmediate&amp;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; Holder : Holders)</span><br><span class="line">		&#123;</span><br><span class="line">			Holder-&gt;<span class="built_in">ReleasePreserved</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogPersistentSceneTexture, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Released %d holder(s)&quot;</span>), Holders.<span class="built_in">Num</span>());</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** PersistentSceneTexture.cpp **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">FPersistentSceneTextureHolder::<span class="built_in">FPersistentSceneTextureHolder</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">ENQUEUE_RENDER_COMMAND</span>(PreserveSceneTexture)([<span class="keyword">this</span>](FRHICommandListImmediate&amp;)</span><br><span class="line">	&#123;</span><br><span class="line">		FPersistentSceneTextureManager::Holders.<span class="built_in">Add</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">FPersistentSceneTextureHolder::~<span class="built_in">FPersistentSceneTextureHolder</span>()</span><br><span class="line">&#123;</span><br><span class="line">	FPersistentSceneTextureManager::Holders.<span class="built_in">Remove</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>此时有一个小细节需要考虑</strong>：我们将上述代码中的三个类/结构体的成员变量都放在了渲染线程上，或着说<strong>这些变量渲染线程安全</strong>（Rendering Thread-Safe），而游戏线程（Game Thread）需要将对两个变量的修改使用宏 <code>ENQUEUE_RENDER_COMMAND</code> 派发到渲染线程上去做。由于 Task Graph 能够为我们保证线程安全，因此此处我们就不用对成员变量的访问加锁了。</p>
<blockquote>
<p>此处当然也可以用 FCriticalSection 配合类似于 FScopeLock，对所有变量的 getter/setter 方法做临界区，但由于此处绝大多数的操作都将会在渲染线程执行，而这种无差别锁可能会导致性能下降。在修改一些现有的单线程耗时方法（使其可以直接用 ParallelFor 加速）时，或者保护所有线程都有可能访问到的全局变量时可以使用临界区，但<strong>在明确知道数据流向</strong>时还是使用线程安全的数据结构（例如 Task Graph 中的无锁队列）来传递数据，做到”无锁编程“吧。</p>
</blockquote>
</li>
<li><p><strong>截帧/删除截帧的操作。</strong>可以看到，此处截帧操作只更改了 <code>bShouldPreserveCurrent</code> 的值，即截帧标记为 true。由于下达截帧命令的一瞬间，我们是不能做到截帧的，而<strong>只能在渲染器在渲染下一帧的途中，通过这个标记来判断是否要把当前渲染得到的纹理截取下来，然后将标记置为 false。</strong>删除比较好说，直接把引用的纹理释放即可。此处保留帧使用的是侵入式引用计数指针 <em>TRefCountPtr</em>，这也是我们从 RDG 提取图时需要采用的指针类型，在想删除保留帧时直接调用其 <code>SafeRelease()</code> 方法即可，剩下的事情就交给纹理本身和 RDG 进行回收吧。</p>
</li>
<li><strong>截取保留帧和 Debug Pass 的实现。</strong>做好了调用框架和标记，剩下需要做的自然就是截取行为本身了。我们这里为了能够直接不依赖材质看到截取帧，同时加入了 Debug 功能。具体实现将放在下一章解释。</li>
</ul>
<h3 id="在-Tonemapping-后添加截取逻辑"><a href="#在-Tonemapping-后添加截取逻辑" class="headerlink" title="在 Tonemapping 后添加截取逻辑"></a>在 Tonemapping 后添加截取逻辑</h3><p>接下来我们分析如何在渲染时截出这一帧。我们都知道，在渲染器的后处理过程中，会有一个步骤叫 Tonemapping，其将一个高动态范围的，描述场景物理光照的纹理重映射到显示器能够显示的，（可能是）低动态范围的纹理上，<strong>这同时正是我们想要截取的纹理</strong>。同样，在 Tonemap Pass 后面还紧跟着一个后处理材质 Pass，即 <code>EPass::PostProcessMaterialAfterTonemapping</code>，我们可以直接将截取到的低动态范围纹理提供到后处理材质中来实现花哨的渐变效果。</p>
<p>明确了截取位置，那我们就可以找到该位置并且注入我们的截取代码了。<strong>在后处理中添加一个自定义 Pass 分为三步</strong>：</p>
<ul>
<li><p><strong>注册该 Pass 到后处理堆栈中</strong>。注册过程在 <code>AddPostProcessingPass</code> （适用于桌面渲染器）和 <code>AddMobilePostProcessingPass</code>（适用于移动端渲染器）函数内定义的 <em>EPass</em> 强类型枚举中。同样，为了 Debug 方便，我们同样需要加入该 Pass 的名字到字符串数组 <code>PassNames[]</code> 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EPass</span> : uint32</span><br><span class="line">&#123;</span><br><span class="line">    MotionBlur,</span><br><span class="line">    Tonemap,</span><br><span class="line">    PreserveSceneColor, <span class="comment">// 加入我们的截取帧 Pass 枚举</span></span><br><span class="line">    FXAA,</span><br><span class="line">    PostProcessMaterialAfterTonemapping,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> TCHAR* PassNames[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TEXT</span>(<span class="string">&quot;MotionBlur&quot;</span>),</span><br><span class="line">    <span class="built_in">TEXT</span>(<span class="string">&quot;Tonemap&quot;</span>),</span><br><span class="line">    <span class="built_in">TEXT</span>(<span class="string">&quot;PreserveSceneColor&quot;</span>), <span class="comment">// 加入我们的截取帧 Pass 名称</span></span><br><span class="line">    <span class="built_in">TEXT</span>(<span class="string">&quot;FXAA&quot;</span>),</span><br><span class="line">    <span class="built_in">TEXT</span>(<span class="string">&quot;PostProcessMaterial (AfterTonemapping)&quot;</span>),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意，后处理堆栈<strong>是对顺序有要求的</strong>。上述枚举，名称，包括之后自定义 Pass 的绘制顺序都要一致，否则会报错。</p>
</blockquote>
</li>
<li><p><strong>判断该 Pass 是否在此帧绘制中开启</strong>。使用 <code>PassSequence.SetEnabled</code> 方法，并传入上述 <em>EPass</em> 枚举值和一个布尔变量来决定该 Pass 是否被启用。该过程不需要严格满足上述顺序，因此可以在开始绘制后处理前的任何位置加入下方代码（原始代码里有大量 <code>PassSequence.SetEnabled</code> 的地方加入即可）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> bEnablePreserveSceneColorPass = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (View.ViewState)</span><br><span class="line">&#123;</span><br><span class="line">    bEnablePreserveSceneColorPass = View.ViewState-&gt;PersistentSceneTextureHolder.bShouldPreserveCurrent;</span><br><span class="line">&#125;</span><br><span class="line">PassSequence.<span class="built_in">SetEnabled</span>(EPass::PreserveSceneColor, bEnablePreserveSceneColorPass);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处使用了 <em>TOverridePassSequence</em> 类模板来<strong>跟踪 Pass 的开启状态和顺序</strong>。该类模板的主要作用是<strong>跟踪最后一个启用的 Pass 是谁</strong>。具体为什么将在之后绘制逻辑处进行说明。</p>
</blockquote>
<p>此处的逻辑由于是针对每一个 View 的，那么我们就可以<strong>直接从 View State 拿到上述截帧标记 <code>bShouldPreserveCurrent</code> 来决定是否开启保留帧 Pass。</strong>轻松！</p>
<p>这里有一个小细节：在后处理中，有一些“后处理”是可以选择是否开启的，该开关通过函数 <code>IsPostProcessingEnabled(View)</code> 决定，其中多半是一些 <em>FEngineShowFlags</em> 的判断；有一些”后处理“是一直会开启的。这两段的逻辑是分开的（尤其是在桌面端渲染部分的实现中），<strong>因此我们需要保证我们的代码同时加入到这个条件成立/不成立的两条分支上，不要漏掉 <code>SetEnabled</code>，同时需要保证绘制顺序。</strong>此处由于篇幅原因就不粘贴大量重复代码了。</p>
<blockquote>
<p>Tips：如何快速测试两条分支是否都实现正确？将 View Mode 从 Lit 切到 Unlit 即可。Unlit 下，<code>IsPostProcessingEnabled(View)</code> 函数将会返回 false。</p>
</blockquote>
</li>
<li><p><strong>执行绘制逻辑</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tonemap Pass...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PassSequence.<span class="built_in">IsEnabled</span>(EPass::PreserveSceneColor))</span><br><span class="line">&#123;</span><br><span class="line">    View.ViewState-&gt;PersistentSceneTextureHolder.<span class="built_in">AddPreservePass</span>(GraphBuilder, View, SceneColor);</span><br><span class="line"></span><br><span class="line">    FScreenPassRenderTarget OverrideOutput;</span><br><span class="line">    PassSequence.<span class="built_in">AcceptOverrideIfLastPass</span>(EPass::PreserveSceneColor, OverrideOutput);</span><br><span class="line">    <span class="keyword">if</span> (PassSequence.<span class="built_in">IsLastPass</span>(EPass::PreserveSceneColor) &amp;&amp; OverrideOutput.<span class="built_in">IsValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AddDrawTexturePass</span>(GraphBuilder, View, SceneColor, OverrideOutput);</span><br><span class="line">        SceneColor = <span class="built_in">static_cast</span>&lt;FScreenPassTexture&gt;(OverrideOutput);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FXAA Pass...</span></span><br></pre></td></tr></table></figure>
<p>当 Pass 序列到了我们定义的 PreserveSceneColor （注意顺序！）时，我们遍可以将我们的 Pass 实现注册进 RDG 中了。具体的实现将在下章提到。不过我们之后还做了一步：检测是否为最后一个 Pass，如果是，则将上一个 Pass 的结果绘制到最终的目标纹理上。</p>
<blockquote>
<p><strong>为什么要干这一步？为什么要对最后一个 Pass 特殊关照？</strong></p>
<p>在后处理堆栈中，每一个 Pass 通常都是那上一个 Pass 的结果（一张纹理），一通渲染之后输出一个结果给到下一个 Pass 中，形成一个 Pass 序列。一个 Pass 输出的结果一般体现在 Pass 逻辑函数的返回值上，代码中常用一个”指针“ <code>SceneColor</code> 来称呼。如果一个 Pass 中不会对纹理的大小、格式等描述信息进行改动的话，很有可能这个 Pass 输出的纹理就是输入的那张纹理，即 <code>SceneColor</code> 指向的纹理是同一张。但是如果这个 Pass 会改变纹理的大小、格式等信息，例如 Tonemapping 和 Upscale Pass，其就会从 RDG 中分配一张新的纹理进行渲染，同时将 <code>SceneColor</code> 改为指向新的纹理。</p>
<p>但是，当后处理结束后，上层调用者并不想拿到一张可能为新的纹理，而是<strong>想让后处理直接输出到已经准备好的纹理上</strong>，这个纹理在代码中被称为 <code>ViewFamilyTexture</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FDeferredShadingSceneRenderer::Render</span></span><br><span class="line">FRDGTextureRef ViewFamilyTexture = <span class="built_in">TryCreateViewFamilyTexture</span>(GraphBuilder, ViewFamily);</span><br></pre></td></tr></table></figure>
<p>回想一下上一章提到的 Viewport 的概念（在附录文章中），其为 <em>FRenderTarget</em> 的派生类，而这里的这张 <code>ViewFamilyTexture</code> 即为 <em>FRenderTarget</em> 里存放的那张 RHI 图：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class FRenderTarget</span></span><br><span class="line">FTexture2DRHIRef RenderTargetTextureRHI;</span><br></pre></td></tr></table></figure>
<p>RHI 层一般会直接把对应图形 API 的 Back Buffer 的纹理（或称 Surface，一般从 Swap Chain 抽取）给到上述变量中。渲染器的目的也是将所有内容渲染到这个纹理上，而不是自创一个新的纹理。如果其是一个 Swap Chain 纹理，那么在创建时则很有可能被优化为”只适用于渲染目标/展示“，例如 DX11/DX12/Vulkan 的 Swap Chain Image 和 OpenGL/GLES 的 Render Buffer，<strong>对其进行读取可能会导致性能损失、未定义行为甚至报错</strong>。</p>
<p>因此，<strong>这张 View Family Texture 不应该在渲染器内部进行读取（Shader Read/Resource），同时这张图也必须成为渲染器的输出（输出的位置倒是没有约束，且不一定只输出一次）。</strong>因此我们需要在相对靠后的 Post Processing 环节的最后一个 Pass，将其输出改变为 View Family Texture，从而需要引入这套判定是否为“最后一个 Pass”的机制。这也意味着，在 Post Processing 过后的任何操作，包括 RenderFinish 环节和 UMG 的渲染均不应该读取该纹理。</p>
<p>（当然，如果该 Viewport 是引擎的一个子视窗，上述限制则都不存在，但毕竟 Scene Renderer 也得适用于单机游戏……）</p>
</blockquote>
<p>虽然我们这个 Pass 并没有渲染出什么东西给下一个 Pass 用，但是由于我们毕竟需要从上一个 Pass 的输出读取内容来截取，因此我们不希望上一个 Pass 被判定为“最后一个 Pass”，从而<strong>输出到一个截取 Pass 不方便读取的纹理上去</strong>，同时我们还要保证，如果原来上一个 Pass 确实是“最后一个 Pass”，那我们需要<strong>替它来做写入到 View Family Texture 的工作</strong>，即增加一个 <code>AddDrawTexturePass</code>。</p>
</li>
</ul>
<h3 id="从-RDG-中截取一帧"><a href="#从-RDG-中截取一帧" class="headerlink" title="从 RDG 中截取一帧"></a>从 RDG 中截取一帧</h3><p>下面让我们开始实现最核心的截取逻辑。此处为了兼容移动平台的小内存和带宽，保留帧逻辑支持分辨率缩放，其通过 Console Variable 体现。同时为了调试方便，我们定义两个 Console Command，用于直接在控制台激活截取/释放逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !(UE_BUILD_SHIPPING || UE_BUILD_TEST)</span></span><br><span class="line"><span class="function">TAutoConsoleVariable&lt;int32&gt; <span class="title">CVarPersistentSceneTextureDrawDebug</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;r.PersistentSceneTexture.Debug&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;Whether to draw persistent scene texture onscreen, for debugging.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">	ECVF_Default</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">TAutoConsoleVariable&lt;<span class="type">float</span>&gt; <span class="title">CVarPersistentSceneTextureScale</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;r.PersistentSceneTexture.Scale&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="number">1.0f</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;Scale applied when preserving scene texture.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">	ECVF_Scalability | ECVF_RenderThreadSafe</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> FAutoConsoleCommand <span class="title">PreserveCurrentSceneTextureCmd</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;r.PersistentSceneTexture.PreserveCurrent&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;Preserve current scene textures.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">	FConsoleCommandDelegate::CreateStatic([]</span></span></span><br><span class="line"><span class="params"><span class="function">	&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		FPersistentSceneTextureManager::PreserveCurrent();</span></span></span><br><span class="line"><span class="params"><span class="function">	&#125;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> FAutoConsoleCommand <span class="title">ReleasePreservedSceneTextureCmd</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;r.PersistentSceneTexture.ReleasePreserved&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;Release all preserved scene textures.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">	FConsoleCommandDelegate::CreateStatic([]</span></span></span><br><span class="line"><span class="params"><span class="function">	&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		FPersistentSceneTextureManager::ReleasePreserved();</span></span></span><br><span class="line"><span class="params"><span class="function">	&#125;))</span></span>;</span><br></pre></td></tr></table></figure>
<p>有了这些 CVar，我们开始实现截取 Pass：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPersistentSceneTextureHolder::AddPreservePass</span><span class="params">(FRDGBuilder&amp; GraphBuilder, <span class="type">const</span> FViewInfo&amp; View,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">const</span> FScreenPassTexture&amp; SourceTexture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ensureMsgf</span>(bShouldPreserveCurrent, <span class="built_in">TEXT</span>(<span class="string">&quot;AddPreservePass called when there is no need to preserve.&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 截取帧纹理的创建</span></span><br><span class="line">	FRDGTextureDesc Desc = SourceTexture.Texture-&gt;Desc;</span><br><span class="line">	Desc.Extent = SourceTexture.ViewRect.<span class="built_in">Size</span>(); <span class="comment">// use viewport size, instead of texture size, therefore getting rid of unused area (editor/camera black bar) to save memory.</span></span><br><span class="line">	<span class="type">float</span> Scale = CVarPersistentSceneTextureScale.<span class="built_in">GetValueOnRenderThread</span>();</span><br><span class="line">	Scale = FMath::<span class="built_in">Clamp</span>(Scale, <span class="number">0.1f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	Desc.Extent.X *= Scale;</span><br><span class="line">	Desc.Extent.Y *= Scale;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> FRDGTextureRef PersistentSceneTexture = GraphBuilder.<span class="built_in">CreateTexture</span>(Desc, <span class="built_in">TEXT</span>(<span class="string">&quot;PersistentSceneTexture&quot;</span>));</span><br><span class="line">	<span class="function"><span class="type">const</span> FScreenPassRenderTarget <span class="title">OutputRT</span><span class="params">(PersistentSceneTexture, ERenderTargetLoadAction::ENoAction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 截取 Pass</span></span><br><span class="line">	<span class="keyword">if</span> (Scale == <span class="number">1.0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Do a subregion copy.</span></span><br><span class="line">		<span class="built_in">AddCopyTexturePass</span>(GraphBuilder, SourceTexture.Texture, PersistentSceneTexture, SourceTexture.ViewRect.Min, FIntPoint::ZeroValue, Desc.Extent);</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogPersistentSceneTexture, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Scene texture preserved, using copy.&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Blit to accommodate scale.</span></span><br><span class="line">		<span class="type">const</span> FScreenPassTextureViewport <span class="built_in">InputViewport</span>(SourceTexture);</span><br><span class="line">		<span class="function"><span class="type">const</span> FScreenPassTextureViewport <span class="title">OutputViewport</span><span class="params">(Desc.Extent)</span></span>;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">const</span> TShaderMapRef&lt;FCopyRectPS&gt; <span class="title">PixelShader</span><span class="params">(View.ShaderMap)</span></span>;</span><br><span class="line">		FCopyRectPS::FParameters* Parameters = GraphBuilder.<span class="built_in">AllocParameters</span>&lt;FCopyRectPS::FParameters&gt;();</span><br><span class="line">		Parameters-&gt;InputTexture = SourceTexture.Texture;</span><br><span class="line">		Parameters-&gt;InputSampler = TStaticSamplerState&lt;SF_Bilinear&gt;::<span class="built_in">GetRHI</span>();</span><br><span class="line">		Parameters-&gt;RenderTargets[<span class="number">0</span>] = OutputRT.<span class="built_in">GetRenderTargetBinding</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">AddDrawScreenPass</span>(GraphBuilder, <span class="built_in">RDG_EVENT_NAME</span>(<span class="string">&quot;PersistentSceneTexturePreservePass&quot;</span>), View, OutputViewport, InputViewport, PixelShader, Parameters);</span><br><span class="line">		<span class="built_in">UE_LOG</span>(LogPersistentSceneTexture, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Scene texture preserved, using a separate pass.&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从 RDG 抽取截取帧到Holder中</span></span><br><span class="line">	GraphBuilder.<span class="built_in">QueueTextureExtraction</span>(PersistentSceneTexture, &amp;PreservedSceneTexture);</span><br><span class="line">	bShouldPreserveCurrent = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体逻辑实现很简单，其进行了三个步骤：</p>
<ol>
<li><p><strong>截取帧纹理的创建</strong>。我们需要截取一个和 Tonemap 之后的纹理相同格式的纹理，因此这里的纹理描述我们直接先拷贝输入纹理的描述。</p>
<p><strong>此时有一个小细节需要考虑</strong>：我们可以直接将输入纹理的全部内容进行拷贝（当然要考虑缩放）。但<strong>原始的输入纹理可能会有未使用的内容，例如黑边</strong>，这可能由以下几种原因造成：</p>
<ul>
<li>分屏时，理论上只保留当前分屏即可，但原始输入纹理可能包含另外一个或多个分屏的内容。</li>
<li>如果游戏/编辑器场景视口缩小，全屏纹理（SceneTexture）不会重新分配，而只有视窗范围会被缩小，因此剩下的地方就被 Clear 成黑色的了，形成“黑边”。</li>
</ul>
<blockquote>
<p>可以看出，在操纵全屏幕纹理时，一定要<strong>将纹理（<em>FRDGTexture</em>）连同着其视窗范围（<em>FIntRect</em>）一起考虑</strong>，因为只有视窗范围内部的内容是有意义的。虚幻当然也考虑到了：</p>
<ul>
<li><em>FScreenPassTexture</em>：纹理 + 视窗范围的包装类</li>
<li><em>FScreenPassRenderTarget</em>：继承自 <em>FScreenPassTexture</em>，增加了 Render Target 的 Load 操作（忽略、读取、Clear）</li>
</ul>
<p>如有可能，在后处理阶段尽量使用这两个类型来传递全屏幕纹理，避免读/写/采样到无意义像素。</p>
</blockquote>
<p>我们可以由两种方法处理：</p>
<ul>
<li><strong>不考虑视窗范围，原样保留输入纹理</strong>。这样做最省事，但对于分屏和编辑器黑边来说，此种做法耗费内存；</li>
<li><strong>剔除无用像素，只截取视窗范围的内容</strong>。此种方法最省内存，<strong>同时截取的纹理可以在非后处理阶段被正常使用</strong>，但因为相当于和 UE 内置逻辑对着干，因此需要在后处理使用到该纹理的逻辑上多下点功夫。</li>
</ul>
<p>两种方法各有利弊，此处选择第二种。因此可以看到在源码中我们直接使用了视窗范围进行新纹理的创建。</p>
</li>
<li><p><strong>截取 Pass</strong>。截取本身的逻辑很简单，就是将输入纹理“拷贝”到输出纹理即可。但“拷贝”本身也有一些实现细节可以优化。当我们不采用缩放时，其实这个拷贝可以被实现为硬件拷贝（可以查看内置 <code>AddCopyTexturePass</code> 的实现），其支持区域拷贝，因此能克服掉黑边，同时因为其不走图形流水线，理论上会节省一些性能；但我们采用缩放后，就只能启用一个全屏幕 Pass，用 Shader 采样的方法来绘制到新纹理上了。</p>
<blockquote>
<p>此处其实可以直接使用内置的 <code>AddDrawTexturePass</code> 方法，但其默认的过滤方法为 Point，即最近邻插值，但我们需要双线性插值来保证最终纹理的质量，因此此处我们展开了该方法。</p>
</blockquote>
<p><strong>此时有一个小细节需要考虑</strong>：在 OpenGL ES 移动端平台上，由于虚幻本身的坐标系和 OpenGL 正好是反着的（遵循着 Direct3D 约定，即左上角为 0, 0），所以 OpenGL ES 平台在 Tonemap 过程中，当之后没有后处理材质时，将会翻转 UV，代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TonemapperInputs.bFlipYAxis = <span class="built_in">RHINeedsToSwitchVerticalAxis</span>(View.<span class="built_in">GetShaderPlatform</span>()) &amp;&amp; !PassSequence.<span class="built_in">IsEnabled</span>(EPass::PostProcessMaterialAfterTonemapping);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Unity 在非 OpenGL 平台也得反一下，因为 Unity 遵循的是 OpenGL 约定。</p>
</blockquote>
<p>同样，在 Tonemapping 之后的后处理材质也会翻转一下，因为在有后处理材质时，前面的 Tonemap 就不会翻转了。代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostProcessMaterialInputs.bFlipYAxis = <span class="built_in">RHINeedsToSwitchVerticalAxis</span>(View.<span class="built_in">GetShaderPlatform</span>()) &amp;&amp; bLastPass;</span><br></pre></td></tr></table></figure>
<p><strong>这就会产生一个很尴尬的问题</strong>：如果截帧 Pass 开启的那一帧并没有 Tonemapping 后的后处理材质，<strong>在 OpenGL ES 移动端截到的图就是反着的</strong>！同时，由于后处理 Shader 中是通过反转 ViewportUV 来做到最后一个后处理材质输出一个翻转的图，而如果我们上述选用了“剔除无用像素，只截取视窗范围的内容”的处理方法，并且 Shader 中没有做额外反转逻辑的话，<strong>即使截图是正的，后处理材质输出的也是反着的</strong>（这也算是和 UE 对着干所付出的代价吧）！我们可以通过在截取时使用自定义 Pixel Shader 反转 UV 进行绘制，并且在下一篇文章中提到的 Shader UV 逻辑上加入反转逻辑，但一是因为篇幅所限，二是此处我们只考虑桌面平台，因此没有将修正过的实现展示出来。感兴趣的小伙伴可以自行实现。</p>
</li>
</ol>
<ol>
<li><p><strong>从 RDG 抽取截取帧到 Holder 中</strong>。由于 RDG 的纹理资源 <em>FRDGTexture</em> 的生命周期默认在其内部管理，但由于我们要从外部持续保留我们截取出来的纹理，因此需要调用 <code>QueueTextureExtraction</code>，将创建出来的纹理资源提取到外部。</p>
<blockquote>
<p><strong>RDG 概念速览：</strong></p>
<ul>
<li>由于 RDG 为 Render Pass 的组织者，因此在不同 Pass 间传递的 Render Target 即被成为 <em>FPooledRenderTarget</em>，其继承自 <em>IPooledRenderTarget</em> 抽象类，其另外一个继承分支是 <em>FRDGTransientRenderTarget</em>。其内嵌引用计数，且将会在引用计数降至 0 时进行自我销毁（<code>delete this</code>）。</li>
<li><p><em>FPooledRenderTarget</em> 包含一个 <em>FRDGPooledTexture</em> 成员，其为一个 <em>FRHITexture</em> 的封装。</p>
</li>
<li><p>RDG 中大量用到的 <em>FRDGTexture</em> 继承自 <em>FRDGParentResource</em>。其在一般情况下（不考虑 Transient Texture）包含一个 <em>FRDGPooledTexture</em> 加上很多 RDG 专用的资源标记的封装，包括是否为外部注册纹理（例如通过<code>RegisterExternalTexture</code>），是否被提取到RDG外部（例如通过<code>QueueTextureExtraction</code>）等。</p>
</li>
<li>由于其内嵌引用计数，因此引用计数不为 0 时，其资源不会被 RDG 销毁（通过在执行 RDG 时调用的 <code>EndResourcesRHI</code> 函数），而通过 <code>QueueTextureExtraction</code> 得到的 <code>TRefCountPtr&lt;IPooledRenderTarget&gt;</code> 则一直会避免其引用计数降至 0。</li>
<li><code>QueueTextureExtraction</code> 标记的 <em>FRDGTexture</em> 将在 RDG 执行的最后，一切 Pass 执行完毕后才会被提取到传入的外部 <em>TRefCountPtr</em> 中。</li>
</ul>
<p>一个不是很精确的概览如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 套娃（下面的拥有上面的做成员变量）</span><br><span class="line">FRHITexture : FRHIResource</span><br><span class="line">FRDGPooledTexture : FRefCountedObject</span><br><span class="line">FPooledRenderTarget : IPooledRenderTarget</span><br><span class="line">FRDGTexture : FRDGParentResource</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>此时有一个小细节需要考虑</strong>：由于 <code>QueueTextureExtraction</code> <strong>在 RDG 执行的尾声才会被提取</strong>，但如果我们想在提取之后<strong>立刻在后处理材质中使用</strong>，则不能使用存在 View State 里的，“外置的”纹理了，否则拿到的会是一个空指针。我们可以在捕获 Pass 的结尾将这个内部 <em>FRDGTexture</em> 返回出去，在 <code>AddPostProcessingPasses</code> 中将其传入（例如存放于 <em>FPostProcessingInputs</em> ）中，在当前帧时后处理材质用该纹理，在之后帧后处理材质才用 View State 中保存的外置纹理。但鉴于改动过于细碎，此处将不列举出来，有兴趣的同学可以进行尝试。</p>
</li>
</ol>
<h3 id="Debug（可选）"><a href="#Debug（可选）" class="headerlink" title="Debug（可选）"></a>Debug（可选）</h3><p>我们截到一帧之后，便可以供后处理材质进行使用了。但我们在改造材质系统之前，也可以先直接在渲染器中实现一个 Debug Pass，快速预览我们截到的图。这里我们选择在 RenderFinish 阶段渲染我们的 Debug Pass。实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPersistentSceneTextureHolder::AddDebugPass</span><span class="params">(FRDGBuilder&amp; GraphBuilder, <span class="type">const</span> FViewInfo&amp; View,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> FScreenPassRenderTarget&amp; Output)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (CVarPersistentSceneTextureDrawDebug.<span class="built_in">GetValueOnRenderThread</span>() &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (View.ViewState)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> TRefCountPtr&lt;IPooledRenderTarget&gt;&amp; Preserved = View.ViewState-&gt;PersistentSceneTextureHolder.</span><br><span class="line">		                                                          PreservedSceneTexture;</span><br><span class="line">		<span class="keyword">if</span> (!Preserved)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">const</span> FRDGTextureRef PreservedTexture = GraphBuilder.<span class="built_in">RegisterExternalTexture</span>(Preserved);</span><br><span class="line">		<span class="built_in">check</span>(PreservedTexture);</span><br><span class="line">		<span class="keyword">if</span> (PreservedTexture != Output.Texture)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> FScreenPassTextureViewport <span class="title">InputViewport</span><span class="params">(PreservedTexture)</span></span>;</span><br><span class="line">			<span class="function"><span class="type">const</span> FScreenPassTextureViewport <span class="title">OutputViewport</span><span class="params">(<span class="keyword">static_cast</span>&lt;FScreenPassTexture&gt;(Output))</span></span>;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="type">const</span> TShaderMapRef&lt;FCopyRectPS&gt; <span class="title">PixelShader</span><span class="params">(View.ShaderMap)</span></span>;</span><br><span class="line">			FCopyRectPS::FParameters* Parameters = GraphBuilder.<span class="built_in">AllocParameters</span>&lt;FCopyRectPS::FParameters&gt;();</span><br><span class="line">			Parameters-&gt;InputTexture = PreservedTexture;</span><br><span class="line">			Parameters-&gt;InputSampler = TStaticSamplerState&lt;SF_Bilinear&gt;::<span class="built_in">GetRHI</span>();</span><br><span class="line">			Parameters-&gt;RenderTargets[<span class="number">0</span>] = Output.<span class="built_in">GetRenderTargetBinding</span>();</span><br><span class="line"></span><br><span class="line">			<span class="built_in">AddDrawScreenPass</span>(GraphBuilder, <span class="built_in">RDG_EVENT_NAME</span>(<span class="string">&quot;PersistentSceneTextureDebugPass&quot;</span>), View, OutputViewport, InputViewport, PixelShader, Parameters);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RDG 新的知识点我们将在下篇文章《Part.3 自定义材质节点，向材质蓝图截取的保留帧》中说明。</p>
<p>此时，通过上述两个 Console Command，即可<strong>在控制台中截帧，释放截帧，查看截帧</strong>了。</p>
<p>同样，我们可以通过在命令行中输入 <code>Vis Pool</code> 命令查看当前池化的纹理，找到“PersistentSceneTexture”即表明截取成功。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="VisPool.png" alt="image-20220320224507187"></p>
<h4 id="CVar-汇总"><a href="#CVar-汇总" class="headerlink" title="CVar 汇总"></a>CVar 汇总</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// CVar</span><br><span class="line">r.PersistentSceneTexture.Scale</span><br><span class="line">r.PersistentSceneTexture.Debug</span><br><span class="line"></span><br><span class="line">// Cmd</span><br><span class="line">r.PersistentSceneTexture.PreserveCurrent</span><br><span class="line">r.PersistentSceneTexture.ReleasePreserved</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到此为止，核心截取逻辑算是大功告成了。虽然思路很简单，但其涉及到了大量渲染模块的改动，包括 ViewState、渲染器、后处理、RDG 等。<strong>为了兼容这些模块，我们需要考虑大量的细节和极端情况，这也正是在 UE 中进行渲染改造最难的一个环节。</strong></p>
<p>限于篇幅，改造材质编辑器，向后处理材质中加入保留帧节点将在下篇文章《Part.3 自定义材质节点，向材质蓝图截取的保留帧》中呈现。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>本文附录：</p>
<ul>
<li><a href="">UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer</a></li>
</ul>
<p>RDG:</p>
<p>Task Graph:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/394791310">davidpp - UE并发-无锁编程及其在TaskGraph中的应用</a></li>
</ul>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.4%20%E5%88%B6%E4%BD%9C%E6%B8%90%E5%8F%98%E6%9D%90%E8%B4%A8/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.4%20%E5%88%B6%E4%BD%9C%E6%B8%90%E5%8F%98%E6%9D%90%E8%B4%A8/">UE 渲染改造：交叉渐变效果 Part.4 制作渐变材质<span class="note">较早</span></a><div class="line"></div><a id="prev" href="/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.1%20%E5%89%8D%E8%A8%80/">UE 渲染改造：交叉渐变效果 Part.1 前言<span class="note">较新</span></a><div class="line"></div><a id="more" href="/blog/archives">检索全部文章</a></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="https://gavinkg.github.io/blog/blog/">@Gavin_KG</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.5.1" title="v1.5.1">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.5.1';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/blog/js/plugins/sites.js',
    friendsjs: '/blog/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper/swiper-bundle.min.css","js":"https://unpkg.com/swiper/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/blog/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
