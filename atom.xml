<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>malos-blog</title>
  
  <subtitle>邪恶马洛斯的审判之地</subtitle>
  <link href="https://gavinkg.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://gavinkg.github.io/blog/"/>
  <updated>2022-03-22T03:11:29.080Z</updated>
  <id>https://gavinkg.github.io/blog/</id>
  
  <author>
    <name>Gavin_KG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer</title>
    <link href="https://gavinkg.github.io/blog/UE%20%E4%B8%AD%E5%AF%B9%E7%AA%97%E5%8F%A3%E5%92%8C%E8%A7%86%E5%8F%A3%E7%9A%84%E6%8A%BD%E8%B1%A1/"/>
    <id>https://gavinkg.github.io/blog/UE%20%E4%B8%AD%E5%AF%B9%E7%AA%97%E5%8F%A3%E5%92%8C%E8%A7%86%E5%8F%A3%E7%9A%84%E6%8A%BD%E8%B1%A1/</id>
    <published>2022-03-19T16:00:00.000Z</published>
    <updated>2022-03-22T03:11:29.080Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="Viewport-和-Viewport-Client"><a href="#Viewport-和-Viewport-Client" class="headerlink" title="Viewport 和 Viewport Client"></a>Viewport 和 Viewport Client</h4><p>UE 在工作时可以一口气渲染大量的画面：UE 包含有<strong>不同的窗口</strong>，每个窗口也可能会<strong>渲染不同场景</strong>（例如玩家视角和动态小地图），即使是同一个场景也会有不同的角度（例如本地分屏游戏）。UE必须设计一套机制，一是能够做到上述多角度多视图渲染，二是让<strong>场景渲染器</strong>能够一次尽量渲染多个类似角度，这样渲染器在渲染同一场景的不同角度可以用同一套内部资源，节省性能。</p><p>UE 自然已经帮我们考虑完备了。对于不同的窗口：</p><ul><li><p><a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/FViewport/"><em>FViewport</em></a>：继承自 <em>FRenderTarget</em>，<strong>为上述“窗口”的封装</strong>。作为一个窗口，其首先应该提供一个表面（Render Target），这个表面即能被渲染器绘制，又能够被直接用来呈现其内容，作为我们看到的窗口上的图案。其次，它应该也能够提供和响应任何跟窗口有关的数据和事件，例如是否被激活、是否全屏、鼠标按钮/指针行为等。或者说，<strong>此处就是把和一个“窗口”有关的所有 I/O 封装到了一起。</strong>最常见（可以说是唯一）的派生类为 <em>FSceneViewport</em>：</p></li><li><p><a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Slate/FSceneViewport/"><em>FSceneViewport</em></a>：<em>FViewport</em> 的最常见派生类。接入了 Slate 的接口 <em>ISlateViewport</em>，意味着其能够在 Slate 体系中被 Slate 的重绘机制驱动（详见下方介绍的 <code>ISlateViewport::OnDrawViewport</code>）。我们能够直观接触到的引擎窗口的 Viewport 几乎都是<em>FSceneViewport</em>。该类目前没有派生类。</p><hr></li><li><p><a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/FViewportClient/"><em>FViewportClient</em></a>：“抽象”类，不包含任何成员变量，可以看作是一个<strong>窗口的管理器，或“驱动”</strong>。如果说上述 <code>FViewport</code> 只是一个窗口对象，此处我们需要窗口管理器承接引擎逻辑和窗口的桥梁，来驱动窗口的绘制和呈现。</p></li><li><p><a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/FCommonViewportClient/"><em>FCommonViewportClient</em></a>：目前唯一继承自 <code>FViewportClient</code> 的派生类，在基类基础上增加一些使用方法，同时也是<strong>大量实际应用的 ViewportClient 的父类</strong>。</p></li><li><p><a href="https://docs.unrealengine.com/4.27/en-US/API/Editor/UnrealEd/FEditorViewportClient/"><em>FEditorViewportClient</em></a>：<strong>编辑器下</strong>使用的 ViewportClient。</p><p>下面这张图一共包含 9 个 FEditorViewportClient 实例，其中我们能直接看到并参与渲染的有6个，如下图黄色/绿色框所示。隐藏的 3 个为 Viewport 2 对应的正交上、右、后视图（是的，它们被创建出来但没有显示）。</p><p><img src="editor-viewport.png" alt="image-20220314183910857"></p></li><li><p><a href="https://docs.unrealengine.com/4.27/en-US/API/Editor/UnrealEd/FLevelEditorViewportClient/"><em>FLevelEditorViewportClient</em></a>：<strong>编辑器下显示游戏场景</strong>的 ViewportClient，例如我们最常使用的场景编辑窗口。<strong>其包含当前 Editor World 的指针</strong>。</p><p>上图中对应为黄色窗口。</p></li><li><p><a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Engine/UGameViewportClient/"><em>UGameViewportClient</em></a>：<strong>“游戏”专属</strong> ViewportClient。不论是单机运行的游戏（只会有一个实例），还是多 Client 模式启动的 PIE 窗口（可能存在多个实例），都归类于此。<strong>其包含当前 Game World 和 GameInstance 的指针</strong>。</p></li></ul><h4 id="渲染命令的调用过程"><a href="#渲染命令的调用过程" class="headerlink" title="渲染命令的调用过程"></a>渲染命令的调用过程</h4><p>对于 Editor/Game Viewport Client，其都包含一个从 <em>FViewElementDrawer</em> 继承而来的 <strong><code>Draw()</code></strong> 方法，用来绘制其 Viewport 内容。</p><p>其通常情况下会被几种机制调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编辑器下，由 Slate (UI) 驱动的 FSceneViewport 在窗口大小变动时通知 ViewportClient 进行绘制；</span></span><br><span class="line">(...) <span class="comment">// 一些 Slate UI 层级的调用，底层由 Engine Tick 支撑。</span></span><br><span class="line">SViewport::<span class="built_in">OnPaint</span>(...);</span><br><span class="line">FSceneViewport::<span class="built_in">OnDrawViewport</span>(...); <span class="comment">// 每帧调用</span></span><br><span class="line">FSceneViewport::<span class="built_in">ResizeViewport</span>(uint32 NewSizeX, uint32 NewSizeY, EWindowMode::Type NewWindowMode); <span class="comment">// Resize 时调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于实时编辑器窗口（例如勾选了Realtime的场景编辑窗口），UEditorEngine 会在每帧 Tick 的时候直接通知到 ViewportClient 进行绘制。</span></span><br><span class="line">(...)</span><br><span class="line">UEditorEngine::<span class="built_in">Tick</span>(...)</span><br><span class="line">UEditorEngine::<span class="built_in">UpdateSingleViewportClient</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独立游戏时，UGameViewportClient 创建唯一的 FSceneViewport，并且 UGameEngine 直接调用 Viewport 进行绘制。</span></span><br><span class="line">(...)</span><br><span class="line">UGameEngine::<span class="built_in">Tick</span>(...)</span><br><span class="line">UGameEngine::<span class="built_in">RedrawViewports</span>(<span class="type">bool</span> bShouldPresent);</span><br></pre></td></tr></table></figure><p>调用 <code>Draw()</code> 之后的机制如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Viewport 层。将会驱动 ViewportClient 进行 Draw。</span></span><br><span class="line">FViewport::<span class="built_in">Draw</span>(<span class="type">bool</span> bShouldPresent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Viewport Client 层。编辑器走上面，游戏走下面。</span></span><br><span class="line">FEditorViewportClient::<span class="built_in">Draw</span>(FViewport* InViewport, FCanvas* Canvas); </span><br><span class="line">UGameViewportClient::<span class="built_in">Draw</span>(FViewport* InViewport, FCanvas* Canvas);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ViewFamily 层。创建渲染器，将自己传入渲染器中，并开始渲染自己。</span></span><br><span class="line">FRenderModule::<span class="built_in">BeginRenderingViewFamily</span>(FCanvas* Canvas, FSceneViewFamily* ViewFamily);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在渲染线程启动渲染器进行绘制</span></span><br><span class="line"><span class="built_in">RenderViewFamily_RenderThread</span>(..., FSceneRenderer* SceneRenderer);</span><br><span class="line"></span><br><span class="line">FDeferredShadingSceneRenderer::<span class="built_in">Render</span>(FRDGBuilder&amp; GraphBuilder); <span class="comment">// 桌面延迟</span></span><br><span class="line">FMobileSceneRenderer::<span class="built_in">Render</span>(FRDGBuilder&amp; GraphBuilder); <span class="comment">// 移动渲染器</span></span><br></pre></td></tr></table></figure><p>感兴趣的同学也可以自己加断点试试看。</p><h4 id="ViewFamily-和-View"><a href="#ViewFamily-和-View" class="headerlink" title="ViewFamily 和 View"></a>ViewFamily 和 View</h4><p>跟着上面 <code>Draw</code> 的这条调用路径看下去，可以瞥见 ViewFamily 的初始化和 View 的创建过程。</p><ul><li><p><a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/FSceneViewFamily/">FSceneViewFamily</a>：在上述 <code>Draw</code> 时初始化。<strong>其包含一个渲染目标</strong>（即 Viewport 自己，别忘了 Viewport 本身就是一个 RT），以及一个<strong>场景（<em>FSceneInterface</em>）指针</strong>。颇有一种万事俱备，只差渲染的样子。</p><p>但其<strong>为什么叫 Family 呢</strong>？因为其将会包含<strong>一组共享渲染目标和场景，但只有视角不同的 Views</strong>：</p></li><li><p><a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/FSceneView/">FSceneView</a>：包含在 ViewFamily 里的 View 们<strong>共享渲染目标和场景，只有角度不同。可以被称作“视点”</strong>。<strong>所有 View 被渲染器一次渲染完毕</strong>。</p><blockquote><p>虽然不同的 Viewport 也很可能对应同一个场景，但是其会使用不同的渲染器实例进行渲染，性能显然没有同一个渲染器直接渲染好。这也是为什么我们在渲染器源码中能够看到大量的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int32 ViewIndex = <span class="number">0</span>; ViewIndex &lt; Views.<span class="built_in">Num</span>(); ViewIndex++) &#123; ... &#125;</span><br></pre></td></tr></table></figure></blockquote><p>每一个 View 均会在 <code>CalcSceneView</code> 方法中（游戏中实现在 <em>ULocalPlayer</em>，编辑器下实现在 <em>FEditorViewportClient</em> 中）诞生并注册进 ViewFamily。一般情况下，<strong>编辑器下一个 ViewFamily 只会有一个 View</strong>，而游戏中（包括PIE），由于存在多人分屏的情况，<strong>一个 ViewFamily 会存在多个 View</strong>，一个 <em>ULocalPlayer</em>，即一个本地玩家对应一个 View，很符合分屏逻辑是不是。</p><blockquote><p> 当然，多 View 还有一个很关键的用处—— XR 设备（VR/AR/MR）的渲染，但其具体逻辑和分屏有一些不一样，本文不予讨论。</p></blockquote></li><li><p><a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Rendering/Overview/">FSceneRenderer</a>：真正用来渲染 ViewFamily 的渲染器。UE 中现在只存在两个渲染器，分别为桌面端渲染器 <em>FDeferredShadingSceneRenderer</em> 和移动端渲染器 <em>FMobileSceneRenderer</em>。渲染器的具体实现极其复杂，网上也有大量成熟的文章，此处不予赘述。</p><blockquote><p>虽然桌面端渲染器被称为 “Deferred”，但其肯定不是从头到尾都是延迟的。其也内置一套 Forward+ 渲染路径，因此我依然习惯直接称之为桌面端渲染器，用于跟移动端渲染器做区分，而移动端渲染器也实现了一套延迟渲染……只能说命名有点混乱。</p></blockquote></li></ul><h4 id="View-State"><a href="#View-State" class="headerlink" title="View State"></a>View State</h4><p>不错。但有一个很致命的问题——在 UE 中，ViewFamily 啊，View 啊，包括渲染器，都是<strong>每帧开始时创建，结束时销毁的</strong>。但很显然，<strong>有一些持久性数据我们需要横跨多帧</strong>，例如上一帧的剔除、SceneTexture 等渲染数据，<strong>当然也包括此处介绍的保留帧。</strong></p><p>隆重介绍 <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/FSceneViewStateInterface/"><em>FSceneViewStateInterface</em></a> 以及其实现 <em>FSceneViewState</em>。其<strong>常驻在那些不会被每帧重建的结构中</strong>（游戏中为 <em>ULocalPlayer</em>，编辑器中为 <em>FEditorViewportClient</em>），作为<strong>保存持久化数据的容器</strong>。其在初始化 View 时，通过上述介绍过的 <code>CalcSceneView</code> 方法传递给每一个 View，我们便可以在渲染器渲染时直接拿到 ViewState，来获取/存入想要持久化保存的数据了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h4 id=&quot;Viewport-和-Viewport-Client&quot;&gt;&lt;a href=&quot;#Viewport-和-Viewport-Client&quot; class=&quot;headerlink&quot; title=&quot;Viewport 和 Viewp</summary>
      
    
    
    
    
    <category term="UE" scheme="https://gavinkg.github.io/blog/tags/UE/"/>
    
    <category term="UE5" scheme="https://gavinkg.github.io/blog/tags/UE5/"/>
    
  </entry>
  
  <entry>
    <title>UE 渲染改造：交叉渐变效果 Part.1 前言</title>
    <link href="https://gavinkg.github.io/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.1%20%E5%89%8D%E8%A8%80/"/>
    <id>https://gavinkg.github.io/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.1%20%E5%89%8D%E8%A8%80/</id>
    <published>2022-03-19T16:00:00.000Z</published>
    <updated>2022-03-27T10:27:43.120Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Unreal Engine 5 进行实现和演示。</p><blockquote><p>这篇文章所介绍的技术，在原理层面<strong>比较简单</strong>，但如果需要将此技术优雅地植入到引擎现有的庞杂逻辑中，则需要对引擎本身的构成有着一定程度上的了解，因此这篇文章希望能够通过一个具体案例，让初次接触相关方向的读者熟悉 UE 渲染器中各种模块的架构。</p><p>由于 UE 本身非常庞大，想要充分理解其体系中的全部实现细节几乎是不可能的。同时，网上虽然存在的大量<strong>自底向上</strong>，展示类关系图和源码分析的文章，<strong>但是在没有案例和动机的情况下，这些文章的理解难度同样也非常高</strong>，一些文章甚至不如直接亲自阅读源码和打断点看调用堆栈的主动学习方法有效（毕竟 C++ 本身就是给人阅读的）。因此，这里我通过一个具体案例，<strong>自顶向下</strong>地，按需引入 UE 中一些模块的原理，并且展现出思考解决方法的过程，将各种实现方案的优雅性、性能、效果罗列出来并进行取舍，并附上一些延伸阅读材料。<strong>当通过案例大概掌握各个模块的宏观架构之后，再去自底向上地细致了解其实现细节才是学习复杂软件系统的最佳途径。</strong></p><p>如果想直接了解实现过程，<strong>可以忽略所有引用块内的文本</strong>（样式同此段文本），或者直接找到文章中的代码块即可。</p></blockquote><hr><p><img src="ppt.png" alt="Powerpoint 中大量可供选择的转场方法"></p><p>不知道大家有没有发现，游戏的过场动画中，两个机位之间直接切换（即 Hard Cut）比较多，而用花里胡哨的渐变效果的却几乎没有。我认为，一是在游戏一直在效仿的电影行业当中，直接切换的应用比例就非常高，只有在切换大场景/时间线这种需要让用户意识到蒙太奇的存在时才需要做一些渐变切换效果，例如交叉渐变或者擦除渐变（著名的例子包括星战系列、夺宝奇兵，以及一些好莱坞的老电影）；二是，渐变效果注定会在渐变的过程中，让两个镜头的画面同时存在于屏幕上，<strong>在实时渲染中无疑是压力很大的</strong>——渲染器需要在渐变这段时间同时生成两个不同角度机位的画面，甚至这两个机位分别属于完全不同的两个场景。</p><p><img src="uncharted_1.png" alt="《神秘海域4》中的几个经典专场"></p><p>但在游戏的艺术化进程中，我们偶尔也需要通过交叉渐变来满足导演的表达要求。大名鼎鼎的《神秘海域4》中就存在着大量的渐变手法来突出场景的时空转换。正好最近在做自己的小项目时，也遇到了类似的要求，也大概列举了一下几种实现起来比较简单的解决方案：</p><ul><li><p>最暴力的解决方案：同时渲染两个相机呗。但是在 UE 中，如果我想渲染到 RT，需要使用 Scene Capture 2D，然后后处理材质读入两个 RT 做混合，但我又想在渐变完了之后将视角重新交还到角色逻辑上做正常的玩家视角，还得考虑到万一目标视角就是玩家可以立刻控制的呢？这种乱糟糟的逻辑很难保证框架的优雅性，因此放弃。</p></li><li><p>修改 UE 自带的多 View 渲染机制。但简单的阅读代码就可以发现，UE 做出来多 View 机制其实就是针对本地分屏来设计的，在 Base Pass 中，不同的 View 都渲染到同一组 Scene Texture 组合，通过 Viewport 来控制分屏中每一个用户视角的渲染范围。这显然不能直接用在渐变中。</p><p><img src="multi-view_gbuffer.png" alt="multi-view_gbuffer"></p><blockquote><p>当然，我们可以借助着分屏的渲染机制，让渐变前后画面分别对应在 Scene Texture 的不同位置上，但通过改变每一个 View 渲染时的变换矩阵保留原始横纵比（类似于将正常画面挤压到画面左半边/右半边）。在后处理过后增加一个 Pass，将左右半边合成回渐变。这种实现方法可以说是在能够保证渐变前后视角都是动态的情况下，最省性能的做法了（因为两个视角共享一个场景，同时输出的像素数量没有变化），但其在渐变时，将前后视角的渲染分辨率分别在横向上减半，此时再试图去引入升采样机制来弥补分辨率损失的话，可能一片文章真的就写不下了……</p></blockquote></li><li><p>录制视频（FMV）。此种实现方法被大量用在游戏的过场动画中，其拥有最好的画面质量，同时几乎不耗费性能。当然缺点也显而易见，其不能适用于动态视角切换，同时视频的分辨率、码率、文件大小也都会产生问题。</p></li><li><p><strong>在转换之前“截一帧”，转换时用这一帧静态图和转换后的动态视角实现渐变效果。</strong>此种方法不足之处在于渐变前的视角在渐变时变成了静态图，容易穿帮，但其在性能、内存占用和画质上都有不错的表现，非常适用于视角移动不太剧烈的场景中。同时，如果将截的这张图作为自定义节点暴露给材质蓝图的话，借助着 UE 强大的材质编辑能力，使用后处理材质可以完全将渐变效果交给美术来调节。<strong>本文中介绍的既是这种实现方案</strong>。</p></li></ul><blockquote><p>有些人可能会问了，保留一帧有啥可大动干戈改造渲染器的，Reddit 上一搜净是这种实现方法。不过大多数方法仍然是通过使用 Scene Capture 2D 来捕捉场景画面到一个 RT 资源上，进而被后处理材质所使用。Scene Capture 2D 在捕捉场景时，由于和场景视角（View）本身都不是一个 View Family，其性能开销比多 View 渲染还要大很多，虽然只保留一帧，但这一帧显然会造成不小的卡顿，无法作为正式项目的解决方法，<strong>因此需要更改渲染器，让渲染器能够保留特定的一帧，并且提供给后处理材质。</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 Unreal Engine 5 进行实现和演示。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章所介绍的技术，在原理层面&lt;strong&gt;比较简单&lt;/strong&gt;，但如果需要将此技术优雅地植入到引擎现有的庞杂逻辑中，则需要对引擎本身的构成有着一定程度上的了解，因此这</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UE 渲染改造：交叉渐变效果 Part.2 实现渲染管线中保留一帧的功能</title>
    <link href="https://gavinkg.github.io/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E4%BF%9D%E7%95%99%E4%B8%80%E5%B8%A7%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>https://gavinkg.github.io/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E4%BF%9D%E7%95%99%E4%B8%80%E5%B8%A7%E7%9A%84%E5%8A%9F%E8%83%BD/</id>
    <published>2022-03-19T16:00:00.000Z</published>
    <updated>2022-03-27T09:42:39.996Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>将会涉及到的概念：</p><ul><li>UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer。</li><li>RDG、FRDGTexture、FPooledRenderTarget 的理解和使用。</li><li>UE 中后处理（Screen Pass）堆栈，如何增加一个自定义 Pass，如何处理“最后一个 Pass”的逻辑。</li></ul><p>将会更改的引擎源文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主要逻辑：</span><br><span class="line">+ Engine/Source/Runtime/Renderer/Public/PersistentSceneTexture.h</span><br><span class="line">+ Engine/Source/Runtime/Renderer/Private/PersistentSceneTexture.cpp</span><br><span class="line"></span><br><span class="line">将保留帧植入 ViewStates：</span><br><span class="line">* Engine/Source/Runtime/Renderer/Private/ScenePrivate.h</span><br><span class="line"></span><br><span class="line">绘制 Debug：</span><br><span class="line">* Engine/Source/Runtime/Renderer/Private/SceneRendering.cpp</span><br><span class="line"></span><br><span class="line">保留帧截取发生地：</span><br><span class="line">* Engine/Source/Runtime/Renderer/Private/PostProcess/PostProcessing.cpp</span><br></pre></td></tr></table></figure></blockquote><hr><p>我们的思路很简单：找到渲染管线的一个节点，让这个节点渲染出来的图被拷贝到一个新图上，然后存在特定的位置，供后处理材质读取（将在 Part.3 提到）。于是我们得到两个问题：<strong>存在哪个位置？在哪里截取？</strong></p><h3 id="在-ViewState-中存放保留帧对象"><a href="#在-ViewState-中存放保留帧对象" class="headerlink" title="在 ViewState 中存放保留帧对象"></a>在 ViewState 中存放保留帧对象</h3><blockquote><p>为了不破坏篇幅结构，关于 UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer 的梳理将会另起一片文章来写：<a href="">UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer</a></p></blockquote><p>由于 ViewState 对象横跨多帧存在，同时我们需要给可能存在的每一个 View 都进行“截图”操作，<strong>因此将保留帧对象，即保留下来的那张图的指针存放在 ViewState 里再合适不过了</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FSceneViewState</span> : <span class="keyword">public</span> FSceneViewStateInterface, <span class="keyword">public</span> FRenderResource</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    FPersistentSceneTextureHolder PersistentSceneTextureHolder;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <em>FPersistentSceneTextureHolder</em> 即承载了包含截图纹理的指针的用处，其实现如下（这里为了节省篇幅，直接上全部声明）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FPersistentSceneTextureHolder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将该Holder注册/移除全局管理器“FPersistentSceneTextureManager”</span></span><br><span class="line"><span class="built_in">FPersistentSceneTextureHolder</span>();</span><br><span class="line">~<span class="built_in">FPersistentSceneTextureHolder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于该类归属于ViewState，为了保险起见，禁用拷贝</span></span><br><span class="line"><span class="built_in">FPersistentSceneTextureHolder</span>(<span class="type">const</span> FPersistentSceneTextureHolder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">FPersistentSceneTextureHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> FPersistentSceneTextureHolder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前View的保留帧/释放保留帧实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreserveCurrent</span><span class="params">()</span> </span>&#123; bShouldPreserveCurrent = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleasePreserved</span><span class="params">()</span> </span>&#123; PreservedSceneTexture.<span class="built_in">SafeRelease</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取保留帧Pass和Debug Pass的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddPreservePass</span><span class="params">(FRDGBuilder&amp; GraphBuilder, <span class="type">const</span> FViewInfo&amp; View, <span class="type">const</span> <span class="keyword">struct</span> FScreenPassTexture&amp; SourceTexture)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddDebugPass</span><span class="params">(FRDGBuilder&amp; GraphBuilder, <span class="type">const</span> FViewInfo&amp; View, <span class="type">const</span> <span class="keyword">struct</span> FScreenPassRenderTarget&amp; Output)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保留帧指针和保留触发标记</span></span><br><span class="line">TRefCountPtr&lt;IPooledRenderTarget&gt; PreservedSceneTexture;</span><br><span class="line"><span class="type">bool</span> bShouldPreserveCurrent = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体主要需要完成以下几个工作：</p><ul><li><p><strong>构造时将自己注册到一个全局的Holder列表中，析构时再把自己从Holder列表中移除。</strong>设计这个全局列表主要是<strong>方便截帧的命令下达</strong>。我们当然可以遍历所有可能出现的 <em>ULocalPlayer</em> 或者是 <em>FEditorViewportClient</em>，从中找到 ViewState，然后下达命令，但制作一个全局的列表，再构造/析构中动态注册/接触注册的设计思路能够让截帧命令下达逻辑更清晰——直接遍历全局数组即可。</p><p>让我们看一下实现吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** PersistentSceneTexture.h **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 盛放全局Holders列表的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPersistentSceneTextureManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">FPersistentSceneTextureHolder</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态截帧/释放方法。可以在任何线程上调用</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PreserveCurrent</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ReleasePreserved</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 归属于渲染线程，用于存储所有Holders。其定义在 PersistentSceneTexture.cpp 中。</span></span><br><span class="line"><span class="type">static</span> TSet&lt;FPersistentSceneTextureHolder*&gt; Holders;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** PersistentSceneTexture.cpp **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局截帧方法。操作将在渲染线程完成。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPersistentSceneTextureManager::PreserveCurrent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ENQUEUE_RENDER_COMMAND</span>(PreserveSceneTexture)([](FRHICommandListImmediate&amp;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (FPersistentSceneTextureHolder* Holder : Holders)</span><br><span class="line">&#123;</span><br><span class="line">Holder-&gt;<span class="built_in">PreserveCurrent</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogPersistentSceneTexture, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Marking %d holder(s) to preserve...&quot;</span>), Holders.<span class="built_in">Num</span>());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局释放方法。操作将在渲染线程完成。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPersistentSceneTextureManager::ReleasePreserved</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ENQUEUE_RENDER_COMMAND</span>(PreserveSceneTexture)([](FRHICommandListImmediate&amp;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; Holder : Holders)</span><br><span class="line">&#123;</span><br><span class="line">Holder-&gt;<span class="built_in">ReleasePreserved</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogPersistentSceneTexture, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Released %d holder(s)&quot;</span>), Holders.<span class="built_in">Num</span>());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** PersistentSceneTexture.cpp **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">FPersistentSceneTextureHolder::<span class="built_in">FPersistentSceneTextureHolder</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ENQUEUE_RENDER_COMMAND</span>(PreserveSceneTexture)([<span class="keyword">this</span>](FRHICommandListImmediate&amp;)</span><br><span class="line">&#123;</span><br><span class="line">FPersistentSceneTextureManager::Holders.<span class="built_in">Add</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">FPersistentSceneTextureHolder::~<span class="built_in">FPersistentSceneTextureHolder</span>()</span><br><span class="line">&#123;</span><br><span class="line">FPersistentSceneTextureManager::Holders.<span class="built_in">Remove</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此时有一个小细节需要考虑</strong>：我们将上述代码中的三个类/结构体的成员变量都放在了渲染线程上，或着说<strong>这些变量渲染线程安全</strong>（Rendering Thread-Safe），而游戏线程（Game Thread）需要将对两个变量的修改使用宏 <code>ENQUEUE_RENDER_COMMAND</code> 派发到渲染线程上去做。由于 Task Graph 能够为我们保证线程安全，因此此处我们就不用对成员变量的访问加锁了。</p><blockquote><p>此处当然也可以用 FCriticalSection 配合类似于 FScopeLock，对所有变量的 getter/setter 方法做临界区，但由于此处绝大多数的操作都将会在渲染线程执行，而这种无差别锁可能会导致性能下降。在修改一些现有的单线程耗时方法（使其可以直接用 ParallelFor 加速）时，或者保护所有线程都有可能访问到的全局变量时可以使用临界区，但<strong>在明确知道数据流向</strong>时还是使用线程安全的数据结构（例如 Task Graph 中的无锁队列）来传递数据，做到”无锁编程“吧。</p></blockquote></li><li><p><strong>截帧/删除截帧的操作。</strong>可以看到，此处截帧操作只更改了 <code>bShouldPreserveCurrent</code> 的值，即截帧标记为 true。由于下达截帧命令的一瞬间，我们是不能做到截帧的，而<strong>只能在渲染器在渲染下一帧的途中，通过这个标记来判断是否要把当前渲染得到的纹理截取下来，然后将标记置为 false。</strong>删除比较好说，直接把引用的纹理释放即可。此处保留帧使用的是侵入式引用计数指针 <em>TRefCountPtr</em>，这也是我们从 RDG 提取图时需要采用的指针类型，在想删除保留帧时直接调用其 <code>SafeRelease()</code> 方法即可，剩下的事情就交给纹理本身和 RDG 进行回收吧。</p></li><li><strong>截取保留帧和 Debug Pass 的实现。</strong>做好了调用框架和标记，剩下需要做的自然就是截取行为本身了。我们这里为了能够直接不依赖材质看到截取帧，同时加入了 Debug 功能。具体实现将放在下一章解释。</li></ul><h3 id="在-Tonemapping-后添加截取逻辑"><a href="#在-Tonemapping-后添加截取逻辑" class="headerlink" title="在 Tonemapping 后添加截取逻辑"></a>在 Tonemapping 后添加截取逻辑</h3><p>接下来我们分析如何在渲染时截出这一帧。我们都知道，在渲染器的后处理过程中，会有一个步骤叫 Tonemapping，其将一个高动态范围的，描述场景物理光照的纹理重映射到显示器能够显示的，（可能是）低动态范围的纹理上，<strong>这同时正是我们想要截取的纹理</strong>。同样，在 Tonemap Pass 后面还紧跟着一个后处理材质 Pass，即 <code>EPass::PostProcessMaterialAfterTonemapping</code>，我们可以直接将截取到的低动态范围纹理提供到后处理材质中来实现花哨的渐变效果。</p><p>明确了截取位置，那我们就可以找到该位置并且注入我们的截取代码了。<strong>在后处理中添加一个自定义 Pass 分为三步</strong>：</p><ul><li><p><strong>注册该 Pass 到后处理堆栈中</strong>。注册过程在 <code>AddPostProcessingPass</code> （适用于桌面渲染器）和 <code>AddMobilePostProcessingPass</code>（适用于移动端渲染器）函数内定义的 <em>EPass</em> 强类型枚举中。同样，为了 Debug 方便，我们同样需要加入该 Pass 的名字到字符串数组 <code>PassNames[]</code> 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EPass</span> : uint32</span><br><span class="line">&#123;</span><br><span class="line">    MotionBlur,</span><br><span class="line">    Tonemap,</span><br><span class="line">    PreserveSceneColor, <span class="comment">// 加入我们的截取帧 Pass 枚举</span></span><br><span class="line">    FXAA,</span><br><span class="line">    PostProcessMaterialAfterTonemapping,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> TCHAR* PassNames[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TEXT</span>(<span class="string">&quot;MotionBlur&quot;</span>),</span><br><span class="line">    <span class="built_in">TEXT</span>(<span class="string">&quot;Tonemap&quot;</span>),</span><br><span class="line">    <span class="built_in">TEXT</span>(<span class="string">&quot;PreserveSceneColor&quot;</span>), <span class="comment">// 加入我们的截取帧 Pass 名称</span></span><br><span class="line">    <span class="built_in">TEXT</span>(<span class="string">&quot;FXAA&quot;</span>),</span><br><span class="line">    <span class="built_in">TEXT</span>(<span class="string">&quot;PostProcessMaterial (AfterTonemapping)&quot;</span>),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意，后处理堆栈<strong>是对顺序有要求的</strong>。上述枚举，名称，包括之后自定义 Pass 的绘制顺序都要一致，否则会报错。</p></blockquote></li><li><p><strong>判断该 Pass 是否在此帧绘制中开启</strong>。使用 <code>PassSequence.SetEnabled</code> 方法，并传入上述 <em>EPass</em> 枚举值和一个布尔变量来决定该 Pass 是否被启用。该过程不需要严格满足上述顺序，因此可以在开始绘制后处理前的任何位置加入下方代码（原始代码里有大量 <code>PassSequence.SetEnabled</code> 的地方加入即可）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> bEnablePreserveSceneColorPass = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (View.ViewState)</span><br><span class="line">&#123;</span><br><span class="line">    bEnablePreserveSceneColorPass = View.ViewState-&gt;PersistentSceneTextureHolder.bShouldPreserveCurrent;</span><br><span class="line">&#125;</span><br><span class="line">PassSequence.<span class="built_in">SetEnabled</span>(EPass::PreserveSceneColor, bEnablePreserveSceneColorPass);</span><br></pre></td></tr></table></figure><blockquote><p>此处使用了 <em>TOverridePassSequence</em> 类模板来<strong>跟踪 Pass 的开启状态和顺序</strong>。该类模板的主要作用是<strong>跟踪最后一个启用的 Pass 是谁</strong>。具体为什么将在之后绘制逻辑处进行说明。</p></blockquote><p>此处的逻辑由于是针对每一个 View 的，那么我们就可以<strong>直接从 View State 拿到上述截帧标记 <code>bShouldPreserveCurrent</code> 来决定是否开启保留帧 Pass。</strong>轻松！</p><p>这里有一个小细节：在后处理中，有一些“后处理”是可以选择是否开启的，该开关通过函数 <code>IsPostProcessingEnabled(View)</code> 决定，其中多半是一些 <em>FEngineShowFlags</em> 的判断；有一些”后处理“是一直会开启的。这两段的逻辑是分开的（尤其是在桌面端渲染部分的实现中），<strong>因此我们需要保证我们的代码同时加入到这个条件成立/不成立的两条分支上，不要漏掉 <code>SetEnabled</code>，同时需要保证绘制顺序。</strong>此处由于篇幅原因就不粘贴大量重复代码了。</p><blockquote><p>Tips：如何快速测试两条分支是否都实现正确？将 View Mode 从 Lit 切到 Unlit 即可。Unlit 下，<code>IsPostProcessingEnabled(View)</code> 函数将会返回 false。</p></blockquote></li><li><p><strong>执行绘制逻辑</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tonemap Pass...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PassSequence.<span class="built_in">IsEnabled</span>(EPass::PreserveSceneColor))</span><br><span class="line">&#123;</span><br><span class="line">    View.ViewState-&gt;PersistentSceneTextureHolder.<span class="built_in">AddPreservePass</span>(GraphBuilder, View, SceneColor);</span><br><span class="line"></span><br><span class="line">    FScreenPassRenderTarget OverrideOutput;</span><br><span class="line">    PassSequence.<span class="built_in">AcceptOverrideIfLastPass</span>(EPass::PreserveSceneColor, OverrideOutput);</span><br><span class="line">    <span class="keyword">if</span> (PassSequence.<span class="built_in">IsLastPass</span>(EPass::PreserveSceneColor) &amp;&amp; OverrideOutput.<span class="built_in">IsValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AddDrawTexturePass</span>(GraphBuilder, View, SceneColor, OverrideOutput);</span><br><span class="line">        SceneColor = <span class="built_in">static_cast</span>&lt;FScreenPassTexture&gt;(OverrideOutput);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FXAA Pass...</span></span><br></pre></td></tr></table></figure><p>当 Pass 序列到了我们定义的 PreserveSceneColor （注意顺序！）时，我们遍可以将我们的 Pass 实现注册进 RDG 中了。具体的实现将在下章提到。不过我们之后还做了一步：检测是否为最后一个 Pass，如果是，则将上一个 Pass 的结果绘制到最终的目标纹理上。</p><blockquote><p><strong>为什么要干这一步？为什么要对最后一个 Pass 特殊关照？</strong></p><p>在后处理堆栈中，每一个 Pass 通常都是那上一个 Pass 的结果（一张纹理），一通渲染之后输出一个结果给到下一个 Pass 中，形成一个 Pass 序列。一个 Pass 输出的结果一般体现在 Pass 逻辑函数的返回值上，代码中常用一个”指针“ <code>SceneColor</code> 来称呼。如果一个 Pass 中不会对纹理的大小、格式等描述信息进行改动的话，很有可能这个 Pass 输出的纹理就是输入的那张纹理，即 <code>SceneColor</code> 指向的纹理是同一张。但是如果这个 Pass 会改变纹理的大小、格式等信息，例如 Tonemapping 和 Upscale Pass，其就会从 RDG 中分配一张新的纹理进行渲染，同时将 <code>SceneColor</code> 改为指向新的纹理。</p><p>但是，当后处理结束后，上层调用者并不想拿到一张可能为新的纹理，而是<strong>想让后处理直接输出到已经准备好的纹理上</strong>，这个纹理在代码中被称为 <code>ViewFamilyTexture</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FDeferredShadingSceneRenderer::Render</span></span><br><span class="line">FRDGTextureRef ViewFamilyTexture = <span class="built_in">TryCreateViewFamilyTexture</span>(GraphBuilder, ViewFamily);</span><br></pre></td></tr></table></figure><p>回想一下上一章提到的 Viewport 的概念（在附录文章中），其为 <em>FRenderTarget</em> 的派生类，而这里的这张 <code>ViewFamilyTexture</code> 即为 <em>FRenderTarget</em> 里存放的那张 RHI 图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class FRenderTarget</span></span><br><span class="line">FTexture2DRHIRef RenderTargetTextureRHI;</span><br></pre></td></tr></table></figure><p>RHI 层一般会直接把对应图形 API 的 Back Buffer 的纹理（或称 Surface，一般从 Swap Chain 抽取）给到上述变量中。渲染器的目的也是将所有内容渲染到这个纹理上，而不是自创一个新的纹理。如果其是一个 Swap Chain 纹理，那么在创建时则很有可能被优化为”只适用于渲染目标/展示“，例如 DX11/DX12/Vulkan 的 Swap Chain Image 和 OpenGL/GLES 的 Render Buffer，<strong>对其进行读取可能会导致性能损失、未定义行为甚至报错</strong>。</p><p>因此，<strong>这张 View Family Texture 不应该在渲染器内部进行读取（Shader Read/Resource），同时这张图也必须成为渲染器的输出（输出的位置倒是没有约束，且不一定只输出一次）。</strong>因此我们需要在相对靠后的 Post Processing 环节的最后一个 Pass，将其输出改变为 View Family Texture，从而需要引入这套判定是否为“最后一个 Pass”的机制。这也意味着，在 Post Processing 过后的任何操作，包括 RenderFinish 环节和 UMG 的渲染均不应该读取该纹理。</p><p>（当然，如果该 Viewport 是引擎的一个子视窗，上述限制则都不存在，但毕竟 Scene Renderer 也得适用于单机游戏……）</p></blockquote><p>虽然我们这个 Pass 并没有渲染出什么东西给下一个 Pass 用，但是由于我们毕竟需要从上一个 Pass 的输出读取内容来截取，因此我们不希望上一个 Pass 被判定为“最后一个 Pass”，从而<strong>输出到一个截取 Pass 不方便读取的纹理上去</strong>，同时我们还要保证，如果原来上一个 Pass 确实是“最后一个 Pass”，那我们需要<strong>替它来做写入到 View Family Texture 的工作</strong>，即增加一个 <code>AddDrawTexturePass</code>。</p></li></ul><h3 id="从-RDG-中截取一帧"><a href="#从-RDG-中截取一帧" class="headerlink" title="从 RDG 中截取一帧"></a>从 RDG 中截取一帧</h3><p>下面让我们开始实现最核心的截取逻辑。此处为了兼容移动平台的小内存和带宽，保留帧逻辑支持分辨率缩放，其通过 Console Variable 体现。同时为了调试方便，我们定义两个 Console Command，用于直接在控制台激活截取/释放逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !(UE_BUILD_SHIPPING || UE_BUILD_TEST)</span></span><br><span class="line"><span class="function">TAutoConsoleVariable&lt;int32&gt; <span class="title">CVarPersistentSceneTextureDrawDebug</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">TEXT(<span class="string">&quot;r.PersistentSceneTexture.Debug&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">TEXT(<span class="string">&quot;Whether to draw persistent scene texture onscreen, for debugging.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">ECVF_Default</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">TAutoConsoleVariable&lt;<span class="type">float</span>&gt; <span class="title">CVarPersistentSceneTextureScale</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">TEXT(<span class="string">&quot;r.PersistentSceneTexture.Scale&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">1.0f</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">TEXT(<span class="string">&quot;Scale applied when preserving scene texture.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">ECVF_Scalability | ECVF_RenderThreadSafe</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> FAutoConsoleCommand <span class="title">PreserveCurrentSceneTextureCmd</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">TEXT(<span class="string">&quot;r.PersistentSceneTexture.PreserveCurrent&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">TEXT(<span class="string">&quot;Preserve current scene textures.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">FConsoleCommandDelegate::CreateStatic([]</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">FPersistentSceneTextureManager::PreserveCurrent();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> FAutoConsoleCommand <span class="title">ReleasePreservedSceneTextureCmd</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">TEXT(<span class="string">&quot;r.PersistentSceneTexture.ReleasePreserved&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">TEXT(<span class="string">&quot;Release all preserved scene textures.&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">FConsoleCommandDelegate::CreateStatic([]</span></span></span><br><span class="line"><span class="params"><span class="function">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">FPersistentSceneTextureManager::ReleasePreserved();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;))</span></span>;</span><br></pre></td></tr></table></figure><p>有了这些 CVar，我们开始实现截取 Pass：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPersistentSceneTextureHolder::AddPreservePass</span><span class="params">(FRDGBuilder&amp; GraphBuilder, <span class="type">const</span> FViewInfo&amp; View,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">const</span> FScreenPassTexture&amp; SourceTexture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ensureMsgf</span>(bShouldPreserveCurrent, <span class="built_in">TEXT</span>(<span class="string">&quot;AddPreservePass called when there is no need to preserve.&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 截取帧纹理的创建</span></span><br><span class="line">FRDGTextureDesc Desc = SourceTexture.Texture-&gt;Desc;</span><br><span class="line">Desc.Extent = SourceTexture.ViewRect.<span class="built_in">Size</span>(); <span class="comment">// use viewport size, instead of texture size, therefore getting rid of unused area (editor/camera black bar) to save memory.</span></span><br><span class="line"><span class="type">float</span> Scale = CVarPersistentSceneTextureScale.<span class="built_in">GetValueOnRenderThread</span>();</span><br><span class="line">Scale = FMath::<span class="built_in">Clamp</span>(Scale, <span class="number">0.1f</span>, <span class="number">1.0f</span>);</span><br><span class="line">Desc.Extent.X *= Scale;</span><br><span class="line">Desc.Extent.Y *= Scale;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> FRDGTextureRef PersistentSceneTexture = GraphBuilder.<span class="built_in">CreateTexture</span>(Desc, <span class="built_in">TEXT</span>(<span class="string">&quot;PersistentSceneTexture&quot;</span>));</span><br><span class="line"><span class="function"><span class="type">const</span> FScreenPassRenderTarget <span class="title">OutputRT</span><span class="params">(PersistentSceneTexture, ERenderTargetLoadAction::ENoAction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 截取 Pass</span></span><br><span class="line"><span class="keyword">if</span> (Scale == <span class="number">1.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Do a subregion copy.</span></span><br><span class="line"><span class="built_in">AddCopyTexturePass</span>(GraphBuilder, SourceTexture.Texture, PersistentSceneTexture, SourceTexture.ViewRect.Min, FIntPoint::ZeroValue, Desc.Extent);</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogPersistentSceneTexture, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Scene texture preserved, using copy.&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Blit to accommodate scale.</span></span><br><span class="line"><span class="type">const</span> FScreenPassTextureViewport <span class="built_in">InputViewport</span>(SourceTexture);</span><br><span class="line"><span class="function"><span class="type">const</span> FScreenPassTextureViewport <span class="title">OutputViewport</span><span class="params">(Desc.Extent)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> TShaderMapRef&lt;FCopyRectPS&gt; <span class="title">PixelShader</span><span class="params">(View.ShaderMap)</span></span>;</span><br><span class="line">FCopyRectPS::FParameters* Parameters = GraphBuilder.<span class="built_in">AllocParameters</span>&lt;FCopyRectPS::FParameters&gt;();</span><br><span class="line">Parameters-&gt;InputTexture = SourceTexture.Texture;</span><br><span class="line">Parameters-&gt;InputSampler = TStaticSamplerState&lt;SF_Bilinear&gt;::<span class="built_in">GetRHI</span>();</span><br><span class="line">Parameters-&gt;RenderTargets[<span class="number">0</span>] = OutputRT.<span class="built_in">GetRenderTargetBinding</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">AddDrawScreenPass</span>(GraphBuilder, <span class="built_in">RDG_EVENT_NAME</span>(<span class="string">&quot;PersistentSceneTexturePreservePass&quot;</span>), View, OutputViewport, InputViewport, PixelShader, Parameters);</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogPersistentSceneTexture, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;Scene texture preserved, using a separate pass.&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从 RDG 抽取截取帧到Holder中</span></span><br><span class="line">GraphBuilder.<span class="built_in">QueueTextureExtraction</span>(PersistentSceneTexture, &amp;PreservedSceneTexture);</span><br><span class="line">bShouldPreserveCurrent = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体逻辑实现很简单，其进行了三个步骤：</p><ol><li><p><strong>截取帧纹理的创建</strong>。我们需要截取一个和 Tonemap 之后的纹理相同格式的纹理，因此这里的纹理描述我们直接先拷贝输入纹理的描述。</p><p><strong>此时有一个小细节需要考虑</strong>：我们可以直接将输入纹理的全部内容进行拷贝（当然要考虑缩放）。但<strong>原始的输入纹理可能会有未使用的内容，例如黑边</strong>，这可能由以下几种原因造成：</p><ul><li>分屏时，理论上只保留当前分屏即可，但原始输入纹理可能包含另外一个或多个分屏的内容。</li><li>如果游戏/编辑器场景视口缩小，全屏纹理（SceneTexture）不会重新分配，而只有视窗范围会被缩小，因此剩下的地方就被 Clear 成黑色的了，形成“黑边”。</li></ul><blockquote><p>可以看出，在操纵全屏幕纹理时，一定要<strong>将纹理（<em>FRDGTexture</em>）连同着其视窗范围（<em>FIntRect</em>）一起考虑</strong>，因为只有视窗范围内部的内容是有意义的。虚幻当然也考虑到了：</p><ul><li><em>FScreenPassTexture</em>：纹理 + 视窗范围的包装类</li><li><em>FScreenPassRenderTarget</em>：继承自 <em>FScreenPassTexture</em>，增加了 Render Target 的 Load 操作（忽略、读取、Clear）</li></ul><p>如有可能，在后处理阶段尽量使用这两个类型来传递全屏幕纹理，避免读/写/采样到无意义像素。</p></blockquote><p>我们可以由两种方法处理：</p><ul><li><strong>不考虑视窗范围，原样保留输入纹理</strong>。这样做最省事，但对于分屏和编辑器黑边来说，此种做法耗费内存；</li><li><strong>剔除无用像素，只截取视窗范围的内容</strong>。此种方法最省内存，<strong>同时截取的纹理可以在非后处理阶段被正常使用</strong>，但因为相当于和 UE 内置逻辑对着干，因此需要在后处理使用到该纹理的逻辑上多下点功夫。</li></ul><p>两种方法各有利弊，此处选择第二种。因此可以看到在源码中我们直接使用了视窗范围进行新纹理的创建。</p></li><li><p><strong>截取 Pass</strong>。截取本身的逻辑很简单，就是将输入纹理“拷贝”到输出纹理即可。但“拷贝”本身也有一些实现细节可以优化。当我们不采用缩放时，其实这个拷贝可以被实现为硬件拷贝（可以查看内置 <code>AddCopyTexturePass</code> 的实现），其支持区域拷贝，因此能克服掉黑边，同时因为其不走图形流水线，理论上会节省一些性能；但我们采用缩放后，就只能启用一个全屏幕 Pass，用 Shader 采样的方法来绘制到新纹理上了。</p><blockquote><p>此处其实可以直接使用内置的 <code>AddDrawTexturePass</code> 方法，但其默认的过滤方法为 Point，即最近邻插值，但我们需要双线性插值来保证最终纹理的质量，因此此处我们展开了该方法。</p></blockquote><p><strong>此时有一个小细节需要考虑</strong>：在 OpenGL ES 移动端平台上，由于虚幻本身的坐标系和 OpenGL 正好是反着的（遵循着 Direct3D 约定，即左上角为 0, 0），所以 OpenGL ES 平台在 Tonemap 过程中，当之后没有后处理材质时，将会翻转 UV，代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TonemapperInputs.bFlipYAxis = <span class="built_in">RHINeedsToSwitchVerticalAxis</span>(View.<span class="built_in">GetShaderPlatform</span>()) &amp;&amp; !PassSequence.<span class="built_in">IsEnabled</span>(EPass::PostProcessMaterialAfterTonemapping);</span><br></pre></td></tr></table></figure><blockquote><p>Unity 在非 OpenGL 平台也得反一下，因为 Unity 遵循的是 OpenGL 约定。</p></blockquote><p>同样，在 Tonemapping 之后的后处理材质也会翻转一下，因为在有后处理材质时，前面的 Tonemap 就不会翻转了。代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostProcessMaterialInputs.bFlipYAxis = <span class="built_in">RHINeedsToSwitchVerticalAxis</span>(View.<span class="built_in">GetShaderPlatform</span>()) &amp;&amp; bLastPass;</span><br></pre></td></tr></table></figure><p><strong>这就会产生一个很尴尬的问题</strong>：如果截帧 Pass 开启的那一帧并没有 Tonemapping 后的后处理材质，<strong>在 OpenGL ES 移动端截到的图就是反着的</strong>！同时，由于后处理 Shader 中是通过反转 ViewportUV 来做到最后一个后处理材质输出一个翻转的图，而如果我们上述选用了“剔除无用像素，只截取视窗范围的内容”的处理方法，并且 Shader 中没有做额外反转逻辑的话，<strong>即使截图是正的，后处理材质输出的也是反着的</strong>（这也算是和 UE 对着干所付出的代价吧）！我们可以通过在截取时使用 <code>AddDrawScreenPass</code> 的可选参数 <code>Flags</code> 指定为 <code>EScreenPassDrawFlags::FlipYAxis</code> ，并且在下一篇文章中提到的 Shader UV 逻辑上加入反转逻辑，但一是因为篇幅所限，二是此处我们只考虑桌面平台，因此没有将修正过的实现展示出来。感兴趣的小伙伴可以自行实现。</p></li></ol><ol><li><p><strong>从 RDG 抽取截取帧到 Holder 中</strong>。由于 RDG 的纹理资源 <em>FRDGTexture</em> 的生命周期默认在其内部管理，但由于我们要从外部持续保留我们截取出来的纹理，因此需要调用 <code>QueueTextureExtraction</code>，将创建出来的纹理资源提取到外部。</p><blockquote><p><strong>RDG 概念速览：</strong></p><ul><li>由于 RDG 为 Render Pass 的组织者，因此在不同 Pass 间传递的 Render Target 即被成为 <em>FPooledRenderTarget</em>，其继承自 <em>IPooledRenderTarget</em> 抽象类，其另外一个继承分支是 <em>FRDGTransientRenderTarget</em>。其内嵌引用计数，且将会在引用计数降至 0 时进行自我销毁（<code>delete this</code>）。</li><li><p><em>FPooledRenderTarget</em> 包含一个 <em>FRDGPooledTexture</em> 成员，其为一个 <em>FRHITexture</em> 的封装。</p></li><li><p>RDG 中大量用到的 <em>FRDGTexture</em> 继承自 <em>FRDGParentResource</em>。其在一般情况下（不考虑 Transient Texture）包含一个 <em>FRDGPooledTexture</em> 加上很多 RDG 专用的资源标记的封装，包括是否为外部注册纹理（例如通过<code>RegisterExternalTexture</code>），是否被提取到RDG外部（例如通过<code>QueueTextureExtraction</code>）等。</p></li><li>由于其内嵌引用计数，因此引用计数不为 0 时，其资源不会被 RDG 销毁（通过在执行 RDG 时调用的 <code>EndResourcesRHI</code> 函数），而通过 <code>QueueTextureExtraction</code> 得到的 <code>TRefCountPtr&lt;IPooledRenderTarget&gt;</code> 则一直会避免其引用计数降至 0。</li><li><code>QueueTextureExtraction</code> 标记的 <em>FRDGTexture</em> 将在 RDG 执行的最后，一切 Pass 执行完毕后才会被提取到传入的外部 <em>TRefCountPtr</em> 中。</li></ul><p>一个不是很精确的概览如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 套娃（下面的拥有上面的做成员变量）</span><br><span class="line">FRHITexture : FRHIResource</span><br><span class="line">FRDGPooledTexture : FRefCountedObject</span><br><span class="line">FPooledRenderTarget : IPooledRenderTarget</span><br><span class="line">FRDGTexture : FRDGParentResource</span><br></pre></td></tr></table></figure></blockquote><p><strong>此时有一个小细节需要考虑</strong>：由于 <code>QueueTextureExtraction</code> <strong>在 RDG 执行的尾声才会被提取</strong>，但如果我们想在提取之后<strong>立刻在后处理材质中使用</strong>，则不能使用存在 View State 里的，“外置的”纹理了，否则拿到的会是一个空指针。我们可以在捕获 Pass 的结尾将这个内部 <em>FRDGTexture</em> 返回出去，在 <code>AddPostProcessingPasses</code> 中将其传入（例如存放于 <em>FPostProcessingInputs</em> ）中，在当前帧时后处理材质用该纹理，在之后帧后处理材质才用 View State 中保存的外置纹理。但鉴于改动过于细碎，此处将不列举出来，有兴趣的同学可以进行尝试。</p></li></ol><h3 id="Debug（可选）"><a href="#Debug（可选）" class="headerlink" title="Debug（可选）"></a>Debug（可选）</h3><p>我们截到一帧之后，便可以供后处理材质进行使用了。但我们在改造材质系统之前，也可以先直接在渲染器中实现一个 Debug Pass，快速预览我们截到的图。这里我们选择在 RenderFinish 阶段渲染我们的 Debug Pass。实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPersistentSceneTextureHolder::AddDebugPass</span><span class="params">(FRDGBuilder&amp; GraphBuilder, <span class="type">const</span> FViewInfo&amp; View,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> FScreenPassRenderTarget&amp; Output)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (CVarPersistentSceneTextureDrawDebug.<span class="built_in">GetValueOnRenderThread</span>() &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (View.ViewState)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> TRefCountPtr&lt;IPooledRenderTarget&gt;&amp; Preserved = View.ViewState-&gt;PersistentSceneTextureHolder.</span><br><span class="line">                                                          PreservedSceneTexture;</span><br><span class="line"><span class="keyword">if</span> (!Preserved)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> FRDGTextureRef PreservedTexture = GraphBuilder.<span class="built_in">RegisterExternalTexture</span>(Preserved);</span><br><span class="line"><span class="built_in">check</span>(PreservedTexture);</span><br><span class="line"><span class="keyword">if</span> (PreservedTexture != Output.Texture)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> FScreenPassTextureViewport <span class="title">InputViewport</span><span class="params">(PreservedTexture)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> FScreenPassTextureViewport <span class="title">OutputViewport</span><span class="params">(<span class="keyword">static_cast</span>&lt;FScreenPassTexture&gt;(Output))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> TShaderMapRef&lt;FCopyRectPS&gt; <span class="title">PixelShader</span><span class="params">(View.ShaderMap)</span></span>;</span><br><span class="line">FCopyRectPS::FParameters* Parameters = GraphBuilder.<span class="built_in">AllocParameters</span>&lt;FCopyRectPS::FParameters&gt;();</span><br><span class="line">Parameters-&gt;InputTexture = PreservedTexture;</span><br><span class="line">Parameters-&gt;InputSampler = TStaticSamplerState&lt;SF_Bilinear&gt;::<span class="built_in">GetRHI</span>();</span><br><span class="line">Parameters-&gt;RenderTargets[<span class="number">0</span>] = Output.<span class="built_in">GetRenderTargetBinding</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">AddDrawScreenPass</span>(GraphBuilder, <span class="built_in">RDG_EVENT_NAME</span>(<span class="string">&quot;PersistentSceneTextureDebugPass&quot;</span>), View, OutputViewport, InputViewport, PixelShader, Parameters);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RDG 新的知识点我们将在下篇文章《Part.3 自定义材质节点，向材质蓝图截取的保留帧》中说明。</p><p>此时，通过上述两个 Console Command，即可<strong>在控制台中截帧，释放截帧，查看截帧</strong>了。</p><p>同样，我们可以通过在命令行中输入 <code>Vis Pool</code> 命令查看当前池化的纹理，找到“PersistentSceneTexture”即表明截取成功。</p><p><img src="VisPool.png" alt="image-20220320224507187"></p><h4 id="CVar-汇总"><a href="#CVar-汇总" class="headerlink" title="CVar 汇总"></a>CVar 汇总</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// CVar</span><br><span class="line">r.PersistentSceneTexture.Scale</span><br><span class="line">r.PersistentSceneTexture.Debug</span><br><span class="line"></span><br><span class="line">// Cmd</span><br><span class="line">r.PersistentSceneTexture.PreserveCurrent</span><br><span class="line">r.PersistentSceneTexture.ReleasePreserved</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到此为止，核心截取逻辑算是大功告成了。虽然思路很简单，但其涉及到了大量渲染模块的改动，包括 ViewState、渲染器、后处理、RDG 等。<strong>为了兼容这些模块，我们需要考虑大量的细节和极端情况，这也正是在 UE 中进行渲染改造最难的一个环节。</strong></p><p>限于篇幅，改造材质编辑器，向后处理材质中加入保留帧节点将在下篇文章《Part.3 自定义材质节点，向材质蓝图截取的保留帧》中呈现。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>本文附录：</p><ul><li><a href="">UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;将会涉及到的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UE 中对窗口和视口的抽象：Viewport、ViewportClient、ViewFamily、View、ViewStates、SceneRenderer。&lt;/li&gt;
&lt;li&gt;RDG、FRDGText</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UE 渲染改造：交叉渐变效果 Part.3 自定义材质节点，向材质蓝图暴露截取的保留帧</title>
    <link href="https://gavinkg.github.io/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.3%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%90%E8%B4%A8%E8%8A%82%E7%82%B9%EF%BC%8C%E5%90%91%E6%9D%90%E8%B4%A8%E8%93%9D%E5%9B%BE%E6%9A%B4%E9%9C%B2%E6%88%AA%E5%8F%96%E7%9A%84%E4%BF%9D%E7%95%99%E5%B8%A7/"/>
    <id>https://gavinkg.github.io/blog/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/UE%20%E6%B8%B2%E6%9F%93%E6%94%B9%E9%80%A0%EF%BC%9A%E4%BA%A4%E5%8F%89%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%20Part.3%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%90%E8%B4%A8%E8%8A%82%E7%82%B9%EF%BC%8C%E5%90%91%E6%9D%90%E8%B4%A8%E8%93%9D%E5%9B%BE%E6%9A%B4%E9%9C%B2%E6%88%AA%E5%8F%96%E7%9A%84%E4%BF%9D%E7%95%99%E5%B8%A7/</id>
    <published>2022-03-19T16:00:00.000Z</published>
    <updated>2022-05-08T13:56:52.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>将会涉及到的概念：</p><ul><li>自定义材质节点，包括节点描述和 HLSL 代码生成机制。</li><li>向后处理材质添加输入纹理。</li></ul><p>将会更改的引擎源文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">自定义材质节点：</span><br><span class="line">+ Engine\Source\Runtime\Engine\Classes\Materials\MaterialExpressionPersistentSceneTexture.h</span><br><span class="line">* Engine\Shaders\Private\SceneTexturesCommon.ush</span><br><span class="line">* Engine\Source\Runtime\Engine\Private\Materials\HLSLMaterialTranslator.cpp</span><br><span class="line">* Engine\Source\Runtime\Engine\Private\Materials\HLSLMaterialTranslator.h</span><br><span class="line">* Engine\Source\Runtime\Engine\Private\Materials\MaterialExpressions.cpp</span><br><span class="line">* Engine\Source\Runtime\Engine\Public\MaterialCompiler.h</span><br><span class="line"></span><br><span class="line">向后处理材质添加输入：</span><br><span class="line">* Engine\Source\Runtime\Renderer\Private\PostProcess\PostProcessMaterial.cpp</span><br><span class="line">* Engine\Source\Runtime\Renderer\Private\PostProcess\PostProcessMaterial.h</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="自定义材质节点"><a href="#自定义材质节点" class="headerlink" title="自定义材质节点"></a>自定义材质节点</h3><p>在上一篇文章中，我们已经在渲染器一侧将截取的逻辑实现完毕了，但只能通过 CVar Debug 的方法来查看截取的一帧，因此这里我们<strong>将这一帧暴露给材质蓝图，让材质能够跟读取普通 Texture 2D 一样读取截取帧。</strong></p><p>先看看最终结果：</p><p><img src="node.png" alt="image-20220322163221670"></p><p><strong>预期的使用方法是：</strong></p><ul><li><p>目前只允许在后处理材质中使用，否则提示错误并拒绝编译。</p></li><li><p>输出 Float4 颜色。如果当前 View 存在截取帧，则输出该帧的采样结果（使用 Bilinear 过滤），如果不存在，输出值未定义。</p></li><li>输入端口 UVs 连接时，使用前序节点结果作为 UV 采样截取帧；若不存在，用同 TexCoords[0] 节点的逻辑获取 UV 采样截取帧。</li><li>UV 需要适配截取方式：截取 Viewport 内 / 截取全部。</li></ul><p>明确了我们要实现的四点需求之后，接下来可以挽袖子开始写节点的逻辑了。</p><p>步骤如下：</p><ul><li><p>声明一个继承自 <em>UMaterialExpression</em> 的类型，来描述我们的自定义节点。这里我们起名为 <em>UMaterialExpressionPersistentSceneTexture</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MaterialExpressionPersistentSceneTexture.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(collapsecategories, hidecategories=Object)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UMaterialExpressionPersistentSceneTexture</span> : <span class="keyword">public</span> UMaterialExpression</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_UCLASS_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** UV in 0..1 range */</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(meta = (RequiredInput = <span class="string">&quot;false&quot;</span>, ToolTip = <span class="string">&quot;Ignored if not specified&quot;</span>))</span><br><span class="line">FExpressionInput Coordinates;</span><br><span class="line"></span><br><span class="line"><span class="comment">//~ Begin UMaterialExpression Interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> int32 <span class="title">Compile</span><span class="params">(<span class="keyword">class</span> FMaterialCompiler* Compiler, int32 OutputIndex)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetCaption</span><span class="params">(TArray&lt;FString&gt;&amp; OutCaptions)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//~ End UMaterialExpression Interface</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>定义该节点长什么样子</p><p>先不急着去实现节点的具体功能。我们这里先告诉 UE 如何展示这个节点，即定义该节点的外貌。节点的输出、类型等在构造函数中定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">UMaterialExpressionPersistentSceneTexture::<span class="built_in">UMaterialExpressionPersistentSceneTexture</span>(<span class="type">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">: <span class="built_in">Super</span>(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITORONLY_DATA</span></span><br><span class="line"><span class="comment">// Structure to hold one-time initialization</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FConstructorStatics</span></span><br><span class="line">&#123;</span><br><span class="line">FText NAME_Texture;</span><br><span class="line"><span class="built_in">FConstructorStatics</span>()</span><br><span class="line">: <span class="built_in">NAME_Texture</span>(<span class="built_in">LOCTEXT</span>( <span class="string">&quot;Texture&quot;</span>, <span class="string">&quot;Texture&quot;</span> ))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> FConstructorStatics ConstructorStatics;</span><br><span class="line"></span><br><span class="line">MenuCategories.<span class="built_in">Add</span>(ConstructorStatics.NAME_Texture); <span class="comment">// 分类为 Texture</span></span><br><span class="line"></span><br><span class="line">bShaderInputData = <span class="literal">true</span>; <span class="comment">// 是红色的输入节点</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">Outputs.<span class="built_in">Reset</span>();</span><br><span class="line">Outputs.<span class="built_in">Add</span>(<span class="built_in">FExpressionOutput</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Color&quot;</span>), <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 输出仅有一个颜色pin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处定义了其分类（如下图所示），标记了其为输入数据（显示为红色节点 + “Input Data”），并且定义了其输出（这里只输出一个颜色）。</p><p><img src="category-texture.png" alt=""></p><p>输入节点是靠定义 UPROPERTY 成员变量的方法来实现的，名字同成员变量的命名（通过 UObject 的反射机制）。当然如果你输入的名字叫 “Coordinates” 的话，UE 会显示为 “UVs”，来统一命名，例如此处。</p><p>当然，最终还剩节点的名称，此处体现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMaterialExpressionPersistentSceneTexture::GetCaption</span><span class="params">(TArray&lt;FString&gt;&amp; OutCaptions)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OutCaptions.<span class="built_in">Add</span>(<span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;PersistentSceneTexture&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现该节点的功能</p><blockquote><p>UE 材质蓝图的一个很重要的功能即为 HLSL 代码段（Code Chunk）的生成和拼接。对于一个普通节点来说，在其编译行为被触发时，它需要驱动上层节点将其逻辑转换为 HLSL 代码段（即编译），传到自己的输入端口，结合上输入生成自己节点的代码段，传递到输出端口上。理论上，整个材质蓝图的代码可以通过触发根节点的编译行为，一次<strong>有向无环图（DAG）的遍历</strong>完全得到，当然UE的实现要复杂很多很多。</p><p>根节点，即材质主节点生成出来的不同用处的代码（主节点不同的 Shading 数据，即一个材质的属性等）将会被填入 MaterialTemplate.ush 中，即完成了材质蓝图到 HLSL 代码的转换，最终结合上不同的 Vertex Factory、不同的 Pass（BasePass / Depth / Shadow 等）、材质内静态开关、光照策略（Lightmap 等）编译出最终的不同图形流水线阶段（VS / PS 等）的 HLSL 代码进行后续工作（例如通过 Mesa IR 变成不同图形 API 代码）。</p><p>例如，Pixel Shader 一般会 Include 两个虚拟的 Shader 文件，分别对应了材质属性（即上述 MaterialTemplate.ush）和 Vertex Factory。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;/Engine/Generated/Material.ush&quot;</span><br><span class="line">#include &quot;/Engine/Generated/VertexFactory.ush&quot;</span><br></pre></td></tr></table></figure><hr><p>在编译时，我们需要将上述 HLSL 代码段（Code Chunk）进行传递。比起直接用字符串进行传递，我们每次需要将代码段添加到全局数组中，得到其下标，然后<strong>用下标进行传递</strong>。这个数组不但会存储代码块，还会存储其哈希值（使用 CityHash64 生成），用于判断重复代码，因此如果重复则不会向数组中再度添加代码，并返回现有代码段的下标。当然，UE 提供了 <code>AddCodeChunck</code> 系列函数来辅助这一操作。</p></blockquote><p>下面我们来实现该节点的功能，即 <code>Compile</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">UMaterialExpressionPersistentSceneTexture::Compile</span><span class="params">(<span class="keyword">class</span> FMaterialCompiler* Compiler, int32 OutputIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">int32 UVCode = INDEX_NONE;</span><br><span class="line"><span class="keyword">if</span> (Coordinates.<span class="built_in">GetTracedInput</span>().Expression)</span><br><span class="line">&#123;</span><br><span class="line">UVCode = Coordinates.<span class="built_in">Compile</span>(Compiler);</span><br><span class="line">&#125;</span><br><span class="line">int32 Result = Compiler-&gt;<span class="built_in">PersistentSceneTextureLookup</span>(UVCode); <span class="comment">// todo!</span></span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMaterialExpressionPersistentSceneTexture::GetCaption</span><span class="params">(TArray&lt;FString&gt;&amp; OutCaptions)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OutCaptions.<span class="built_in">Add</span>(<span class="built_in">FString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;PersistentSceneTexture&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在节点中，我们处理了前序节点的输入，然后直接将工作交给了将 Shader Graph 转换成代码的“材质蓝图编译器”来执行，即代码中 <code>Compiler-&gt;PersistentSceneTextureLookup(UVCode)</code>。接下来我们就要深入编译器来实现这些。</p></li></ul><h3 id="向材质蓝图编译器增加功能"><a href="#向材质蓝图编译器增加功能" class="headerlink" title="向材质蓝图编译器增加功能"></a>向材质蓝图编译器增加功能</h3><p>由于在虚幻的设计中，材质蓝图编译器可以由多个“后端”构成，但当前似乎 UE 只实现出了一个编译成 HLSL 的版本，得到的 HLSL 将会使用 HLSLCrossCompile 被编译成 IR 再转换到其余各家图形 API 需要的 Shader 代码/IL，例如 SPIR-V 和 GLSL。<strong>因此我们只需要关心怎么将我们的逻辑转换为 HLSL 代码即可。</strong></p><blockquote><p>此处具体怎么 Cross-compile 还是去看看其他大佬的文章吧。<a href="https://docs.unrealengine.com/5.0/en-US/cross-compiler-in-unreal-engine/">UE5 doc</a> 中还是只提到了 MESA IR，但 UE 的 Third-party 中也出现了诸如 ShaderConductor ，DXC 和 SPIRV-Cross 的身影，感觉是生成 DXIL 给 DX12，剩下的一律走 SPIR-V。此处如果有误还请务必评论/私信纠正我，万分感谢。</p></blockquote><p>首先，在材质蓝图编译器的基类 <code>FMaterialCompiler</code> 中添加纯虚函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> int32 <span class="title">PersistentSceneTextureLookup</span><span class="params">(int32 UV)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>由于是纯虚函数，因此我们需要在所有继承类中来定义这个实现，其中包括 <code>FHLSLMaterialTranslator</code> 和 <code>FProxyMaterialTranslator</code>。前者比较好理解，就是我们材质蓝图 -&gt; HLSL 的具体实现位置。在源码中，后者似乎是为了给其他功能和工具所做的代理，因此设计为直通（Pass-through）。</p><p>接着，我们前往 <code>FHLSLMaterialTranslator</code> 来给予这个纯虚函数一个实现。这里为了直观，同样直接上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">FHLSLMaterialTranslator::PersistentSceneTextureLookup</span><span class="params">(int32 UV)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Material-&gt;<span class="built_in">GetMaterialDomain</span>() != MD_PostProcess)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Errorf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Persistent scene texture is only available in post process materials.&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (UV == INDEX_NONE)</span><br><span class="line">&#123;</span><br><span class="line">UV = <span class="built_in">TextureCoordinate</span>(<span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">AddEstimatedTextureSample</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">AddCodeChunk</span>(MCT_Float4, <span class="built_in">TEXT</span>(<span class="string">&quot;CalcPersistentSceneTextureColor(%s)&quot;</span>), *<span class="built_in">GetParameterCode</span>(UV)); <span class="comment">// todo!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处做了这样几件事情：</p><ul><li><p>因为我们只会在后处理阶段将截取的一帧送入 Shader 中，因此此处需要判断材质是否为后处理，如果不是的话就含泪退出吧。</p></li><li><p>如果输入的 UV 为空，即材质蓝图的 “UVs” 节点并未连接内容，此处 Fallback 到一个 <code>FHLSLMaterialTranslator::TextureCoordinate</code> 函数，从而得到一个计算“全屏幕 UV”的 HLSL 代码。</p></li><li><p>由于我们此处需要对保留帧进行 1 次采样，因此我们用 <code>AddEstimatedTextureSample</code> 来提示引擎将会进行的这一次采样（因为引擎在没拿到源码时并不知道源码中采样了几次，因此此处称之为“Estimate”。其会显示在材质的 Stats 窗口中，如下图所示：</p><p><img src="est.png" alt="est"></p></li><li><p>最终我们使用 <code>AddCodeChunk</code> 将我们在 Shader 中实现的具体渲染保留帧的 HLSL 代码，搭配上我们得到的 UV 整合成最终的代码段。</p></li></ul><p>材质蓝图编译器搞定后，现在的重任来到了 shader 这边。我们需要继续在 Shader 层面实现 <code>CalcPersistentSceneTextureColor</code> 函数，通过 UV 得到最终颜色值。</p><h3 id="实现-Shader-采样保留帧的功能"><a href="#实现-Shader-采样保留帧的功能" class="headerlink" title="实现 Shader 采样保留帧的功能"></a>实现 Shader 采样保留帧的功能</h3><p>还记得之前我们要求待编译的材质是后处理吗？因此此处我们要将 Shader 中的功能添加到后处理材质 Shader 本身或其 include 的头文件，来实现 Shader 采样保留帧。此处我们选择将逻辑添加进 <code>/Engine/Private/SceneTexturesCommon.ush</code> 中，因为采样我们这里的保留帧和采样其它场景纹理颇为相似（代码复制粘贴也方便w）。</p><blockquote><p>所以后处理材质 Shader 是什么呢？我们顺着渲染器的 Pass，找到 <code>PostProcessMaterial.cpp</code>，扫一眼即可轻松找到 C++ 侧对 Shader 的定义类 <code>FPostProcessMaterialVS</code> / <code>FPostProcessMaterialPS</code>，以及标记其 Shader usf 位置、类型和函数入口的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IMPLEMENT_SHADER_TYPE</span>(,FPostProcessMaterialVS, <span class="built_in">TEXT</span>(<span class="string">&quot;/Engine/Private/PostProcessMaterialShaders.usf&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;MainVS&quot;</span>), SF_Vertex);</span><br><span class="line"><span class="built_in">IMPLEMENT_SHADER_TYPE</span>(,FPostProcessMaterialPS, <span class="built_in">TEXT</span>(<span class="string">&quot;/Engine/Private/PostProcessMaterialShaders.usf&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;MainPS&quot;</span>), SF_Pixel);</span><br></pre></td></tr></table></figure><p>显然，其为了兼容材质蓝图，包含了 <code>/Engine/Generated/Material.ush</code> ，即材质蓝图生成后的文件（来源于 <code>MaterialTemplate.ush</code>）。</p></blockquote><p>上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Texture2D PersistentSceneTexture;</span><br><span class="line">SamplerState PersistentSceneTextureSampler;</span><br><span class="line">float4 CalcPersistentSceneTextureColor(float2 UV)</span><br><span class="line">&#123;</span><br><span class="line">#if (POST_PROCESS_MATERIAL || POST_PROCESS_MATERIAL_MOBILE)</span><br><span class="line">return Texture2DSampleLevel(PersistentSceneTexture, PersistentSceneTextureSampler, UV, 0);</span><br><span class="line">#endif</span><br><span class="line">return float4(1.0f, 0.0f, 0.0f, 1.0f); // translator will not even compile if not being a post process material.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处我们先在 Shader 侧定义了一个 Texture2D 和一个 Sampler，然后直接返回采样值即可，非常简单。至于这个 Texture2D 和 Sampler 具体值是什么，我们就需要在给后处理材质配置参数的时候来指定了，请见下一章。</p><h3 id="向后处理材质传入截取帧"><a href="#向后处理材质传入截取帧" class="headerlink" title="向后处理材质传入截取帧"></a>向后处理材质传入截取帧</h3><p>截取帧准备好了，材质蓝图和 Shader 也准备好了，现在就要实现打通他们的桥梁——将截取帧输入进后处理材质。</p><p>同样，我们找到定义后处理材质输入参数的代码段（位于 <code>PostProcessMaterial.h</code>），加入此处需要的 Texture2D 和 Sampler：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FPostProcessMaterialParameters, )</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_STRUCT_REF</span>(FViewUniformShaderParameters, View)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_STRUCT_INCLUDE</span>(FSceneTextureShaderParameters, SceneTextures)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_STRUCT</span>(FScreenPassTextureViewportParameters, PostProcessOutput)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_STRUCT_ARRAY</span>(FScreenPassTextureInput, PostProcessInput, [kPostProcessMaterialInputCountMax])</span><br><span class="line"></span><br><span class="line"><span class="built_in">SHADER_PARAMETER_RDG_TEXTURE</span>(Texture2D, PersistentSceneTexture)       <span class="comment">// here!</span></span><br><span class="line"><span class="built_in">SHADER_PARAMETER_SAMPLER</span>(SamplerState, PersistentSceneTextureSampler) <span class="comment">// here!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SHADER_PARAMETER_SAMPLER</span>(SamplerState, PostProcessInput_BilinearSampler)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_RDG_TEXTURE</span>(Texture2D, MobileCustomStencilTexture)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_SAMPLER</span>(SamplerState, MobileCustomStencilTextureSampler)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_RDG_TEXTURE</span>(Texture2D, EyeAdaptationTexture)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER_RDG_BUFFER_SRV</span>(Buffer&lt;float4&gt;, EyeAdaptationBuffer)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(int32, MobileStencilValueRef)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(uint32, bFlipYAxis)</span><br><span class="line"><span class="built_in">SHADER_PARAMETER</span>(uint32, bMetalMSAAHDRDecode)</span><br><span class="line"><span class="built_in">RENDER_TARGET_BINDING_SLOTS</span>()</span><br><span class="line"><span class="built_in">END_SHADER_PARAMETER_STRUCT</span>()</span><br></pre></td></tr></table></figure><p>该定义将同时在 C++ 侧和 Shader 侧生效。</p><p>桥梁搭建好了，接下来就剩最后一步：指定传入的数据了。我们找到 <code>PostProcessMaterial.cpp</code> 中的 <code>AddPostProcessMaterialPass</code> 函数，在合适的位置将保留帧传入吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (View.ViewState &amp;&amp; View.ViewState-&gt;PersistentSceneTextureHolder.PreservedSceneTexture)</span><br><span class="line">&#123;</span><br><span class="line">FRDGTextureRef PersistentSceneTexture = GraphBuilder.<span class="built_in">RegisterExternalTexture</span>(View.ViewState-&gt;PersistentSceneTextureHolder.PreservedSceneTexture, ERDGTextureFlags::ReadOnly);</span><br><span class="line">PostProcessMaterialParameters-&gt;PersistentSceneTexture = PersistentSceneTexture;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Give user an ugly green output to remind them to preserve first ;)</span></span><br><span class="line">PostProcessMaterialParameters-&gt;PersistentSceneTexture = GSystemTextures.<span class="built_in">GetGreenDummy</span>(GraphBuilder);</span><br><span class="line">&#125;</span><br><span class="line">PostProcessMaterialParameters-&gt;PersistentSceneTextureSampler = TStaticSamplerState&lt;SF_Bilinear&gt;::<span class="built_in">GetRHI</span>();</span><br></pre></td></tr></table></figure><p>此处在用户进行过截取操作后，当前 View 的 ViewState 中的 Holder 将会具有一个非空的 RDG Texture，因此我们直接把其传到 Shader 参数中即可。若没截取的话，此处选择传一个绿色的 Dummy Texture，告诉用户你应该先截取保留帧再来用这个材质，否则就显示一个丑了吧唧的绿色。当然采样器对象我们直接给一个双线性的即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经历噩梦般的大量改动之后，此处我们终于将一整套保留帧的特性——从截取到展示——实现完毕了。事不宜迟，拉个最简陋的材质看看效果：</p><p><img src="simplemat.png" alt="image-20220508191002266"></p><p>拖入后处理 Volume 后，果不其然，看到了了丑了吧唧的绿色半透明（alpha=0.5）场景：</p><p><img src="mat1.png" alt="1"></p><p>在命令行敲入 <code>r.PersistentSceneTexture.PreserveCurrent</code> 后，转动一点点视角：</p><p><img src="mat2.png" alt="image-20220508191256419"></p><p>揉揉眼睛，没错！保留帧被截取下来并且和当前场景纹理进行了 blend，符合预期。接下来检查一下多 View 下的表现：</p><p><img src="mat3.png" alt="image-20220508191446645"></p><p><img src="mat3rdc.png" alt="image-20220508191612126"></p><p>每个 View 下，保留帧确实是分开的，并且最终绘制时也能正确考虑到 Viewport，保证渲染画面不拉伸。最后看看移动端渲染器（ES31）效果，有兴趣的小伙伴也可以将示例工程部署到 Android OpenGL ES 平台中，来验证一下这个最难对付的 Target 是否渲染正常（笔者本地处理了YFlip，因此打包看是没问题的）：</p><p><img src="mat4.png" alt="image-20220508191916815"></p><p>大功告成！</p><p>在交叉渐变效果的最后一篇文章中，我将会制作几个具体的材质，来演示保留帧能够表现出的效果。Sneak peak：</p><video src="v.mp4"></video>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;将会涉及到的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义材质节点，包括节点描述和 HLSL 代码生成机制。&lt;/li&gt;
&lt;li&gt;向后处理材质添加输入纹理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将会更改的引擎源文件：&lt;/p&gt;
&lt;figure class=&quot;high</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UE4 实现多颜色描边+遮挡高亮，以及移动端效果/性能分析（踩坑实录）</title>
    <link href="https://gavinkg.github.io/blog/UE4%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A2%9C%E8%89%B2%E6%8F%8F%E8%BE%B9+%E9%81%AE%E6%8C%A1%E9%AB%98%E4%BA%AE/"/>
    <id>https://gavinkg.github.io/blog/UE4%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A2%9C%E8%89%B2%E6%8F%8F%E8%BE%B9+%E9%81%AE%E6%8C%A1%E9%AB%98%E4%BA%AE/</id>
    <published>2022-01-04T16:00:00.000Z</published>
    <updated>2022-03-22T03:09:31.890Z</updated>
    
    <content type="html"><![CDATA[<p><img src="banner.jpg" alt="banner"></p><p>示例项目的 GitHub 链接：<a href="https://github.com/GavinKG/UE4-Multicolor-Outline-and-Silhouette">https://github.com/GavinKG/UE4-Multicolor-Outline-and-Silhouette</a></p><p>使用 Unreal Engine 4.27。示例项目未改动引擎。</p><span id="more"></span><h2 id="Part-1-前言"><a href="#Part-1-前言" class="headerlink" title="Part.1 前言"></a>Part.1 前言</h2><p>最近又从引擎底层脱身，打了打美术的杂，也算换换脑子，毕竟要成为全栈游戏制作人嘛（笑。</p><p>这里记录的东西乍一看很简单：<strong>特定物体的描边（Outline）和遮挡高亮（Silhouette），支持标记多种颜色，后处理单材质完成</strong>。嘿，这简单，Sobel 算子整起来！撸起袖子一把游戏的时间连了一个后处理材质，<strong>单 Pass 即可同时做到多颜色 + 描边 + 遮挡高亮 + 遮挡部位暗色</strong>。兴冲冲的打包到手机上才发现寄了，咋啥都没有呢。于是又花了一把游戏的时间，诞生了这篇踩坑笔记。</p><p>哦对了，游戏名字叫《文明6》</p><h2 id="Part-2-材质实现"><a href="#Part-2-材质实现" class="headerlink" title="Part.2 材质实现"></a>Part.2 材质实现</h2><p>踩坑之前，先让我们看看这个多颜色描边高亮<em>理论上</em>到底怎么实现的吧。</p><h3 id="1-更改项目设置"><a href="#1-更改项目设置" class="headerlink" title="1. 更改项目设置"></a>1. 更改项目设置</h3><p>将 Rendering / PostProcessing / Custom Depth-Stencil Pass 更改为 Enabled with Stencil，如下图所示。</p><p><img src="proj_settings.png" alt="proj_settings"></p><h3 id="2-将待描边高亮物体配置-Custom-Depth-Stencil-Write"><a href="#2-将待描边高亮物体配置-Custom-Depth-Stencil-Write" class="headerlink" title="2. 将待描边高亮物体配置 Custom Depth / Stencil Write"></a>2. 将待描边高亮物体配置 Custom Depth / Stencil Write</h3><p>找到想要描边的网格物体（<code>UPrimitiveComponent</code>），<strong>勾选 “Render CustomDepth Pass”</strong>，既可以启用绘制到自定义深度和模板缓冲。</p><p>其实如果将鼠标悬停在上述复选框中，可以看到下面这段话。看来这可是官方钦点的做法啊！</p><blockquote><p>If true, this component will be rendered in the CustomDepth pass (usually used for outlines)</p></blockquote><h3 id="3-实现-Sobel-算子得到边缘-Mask"><a href="#3-实现-Sobel-算子得到边缘-Mask" class="headerlink" title="3. 实现 Sobel 算子得到边缘 Mask"></a>3. 实现 Sobel 算子得到边缘 Mask</h3><p>我们新建一个 Material Function，直接按照 <a href="https://en.wikipedia.org/wiki/Sobel_operator">Wikipedia 给出的公式</a> 来算出梯度大小的平方。材质比较乱，直接上个预览图吧，要原始材质的的可以去文末的 Github 工程中找到。</p><p><img src="sobel_stencil.png" alt="sobel_stencil"></p><p><strong>这里我是用的 CustomStencil 节点采样得出的梯度</strong>，因为要参与描边的物体 Stencil 肯定大于等于1，因此所有大于 1 的梯度都可以看成是描边的边缘，因此直接 Saturate 以后可以直接形成边缘 Mask，0 代表没有描边，1 代表需要描边。</p><p>但如果使用 CustomDepth 进行梯度计算，则需要指定一个描边梯度最小值和最大值，然后将得到的数据映射进去，再 clamp 输出。<strong>关于使用 CustomDepth 还是 CustomStencil 将会在下一章讨论。</strong></p><p>我们可以通过<strong>控制相邻8个采样点的间隔距离</strong>来顺便控制一下描边的粗细。此时其实一个描边材质就实现完毕了。</p><p><img src="sobel_stencil_node.png" alt="image-20220108153018380"></p><h3 id="4-取得遮挡物体-Mask"><a href="#4-取得遮挡物体-Mask" class="headerlink" title="4. 取得遮挡物体 Mask"></a>4. 取得遮挡物体 Mask</h3><p>既然我们已经得出边缘 Mask 了，现在想看看能不能得出被遮挡物体的 Mask，来实现遮挡高亮效果。<strong>直接拿到遮挡部分似乎有点费劲</strong>，虽然说一个物体被遮挡后，其 CustomDepth 的值（物体场景深度）应该是<strong>大于</strong> SceneDepth 的值（遮挡物场景深度），即 CustomDepth 更远一些，但考虑那些根本就不存在绘制自定义深度物体的像素，其CustomDepth 采样值是远平面值，而其 SceneDepth 值不一定是远平面了，可能是不画 Custom Depth 的物体的值，导致 CustomDepth 依旧比 SceneDepth 大！但是，如果 Custom Depth 和 Scene Depth 相等的话，说明该像素表示的是<strong>物体可见部分</strong>！于是我们可以首先通过那张 CustomStencil 直接拿到<strong>遮挡物体完整的 Mask</strong>，再减去物体可见部分 Mask，就能得到遮挡部分了。</p><p><img src="mask_flow.png" alt="mask_flow"></p><p>当然，浮点数直接用“等于”去比较是有风险的，尤其是当 SceneDepth 和 CustomDepth 格式都可能不一样的时候。因此此处需要将 Scene Depth 或者 Custom Depth 加上一个 Bias 值，然后相减后将一定范围内的值都看作相等即可。该值可以暴露为参数，用来适配不同平台。</p><p><img src="visible_object_mask.png" alt="visible_object_mask"></p><h3 id="5-根据-CustomStencil-获取对应颜色值"><a href="#5-根据-CustomStencil-获取对应颜色值" class="headerlink" title="5. 根据 CustomStencil 获取对应颜色值"></a>5. 根据 CustomStencil 获取对应颜色值</h3><p>由于此处我就想实现标记敌人/盟友/NPC三种对象，因此我分配 Stencil 值为：1-&gt;敌人（红色），2-&gt;队友（蓝色），3-&gt;NPC（黄色）。首先为了方便修改，此处将颜色配置直接暴露在外部的 Material Parameter Collection（下称MPC）中，然后材质内部根据 CustomStencil 采样值直接选择对应颜色即可。</p><p>当然，如果 Stencil 是 0 的话（可能对应有物体，但 Stencil 写入值是0，或者没写入；可能没有物体），我想输出一个值为0的alpha，不是 0 则输出1，这样外部节点拿到这个 alpha 后可以控制描边高亮的混合参数。</p><p>实现如下，这里直接借用了 UE 自带节点 <code>3ColorBlend</code>：</p><p><img src="color_blend.png" alt="image-20220108163927086"></p><p>由于 Stencil 输入值只可能是离散值，因此我们此处只考虑输入值为 0、1、2、3 时的输出准确性即可。输入小数值和越界值输出结果未定义。</p><p>外部节点拿到颜色之后，可以直接根据遮挡部分 Mask 值，将颜色的饱和度和亮度做调整，实现遮挡部位暗色。</p><h3 id="6-得到最终-Mask-值"><a href="#6-得到最终-Mask-值" class="headerlink" title="6. 得到最终 Mask 值"></a>6. 得到最终 Mask 值</h3><p>拿到边缘和遮挡部分的 Mask 值以后，我们再将遮挡部分的值乘上遮挡混合系数和全局混合系数，直接和 PostProcessInput0 做 Lerp 混合即可输出。大功告成！来个大合照：</p><p><img src="mat.png" alt="mat"></p><p><img src="mat_inspector.png" alt="mat_inspector"></p><p>同理，如果嫌图看不清楚，可以直接根据文末 Github 链接下载源工程。记得点个 Star 哦！</p><h3 id="7-设置全局后处理-Volume，并添加到后处理材质列表中"><a href="#7-设置全局后处理-Volume，并添加到后处理材质列表中" class="headerlink" title="7. 设置全局后处理 Volume，并添加到后处理材质列表中"></a>7. 设置全局后处理 Volume，并添加到后处理材质列表中</h3><p><img src="volume.png" alt="volume"></p><h3 id="8-看看效果"><a href="#8-看看效果" class="headerlink" title="8. 看看效果"></a>8. 看看效果</h3><p><img src="editor_showcase.png" alt="banner"></p><p><img src="without_highlight.png" alt="without_highlight"></p><p>如果一个物体勾选上写入 CustomDepth，但 Stencil 值为 0，其可以成为<strong>“不显示高亮”的遮挡物</strong>，适合用在 FPS 游戏的主角枪械等前景上。</p><p>Demo 场景不过瘾？来个经典的 ActionRPG 项目试试看：</p><video src="showcase-actionrpg.mp4"></video><h2 id="Part-3-移动端的潜在问题"><a href="#Part-3-移动端的潜在问题" class="headerlink" title="Part.3 移动端的潜在问题"></a>Part.3 移动端的潜在问题</h2><p>上述材质的实现其实比较简单，但在我第一次做完之后，却遇到了不少移动端实机上的问题，导致耗时比预想中长出了好几倍。果然还是开发经验不足导致的啊。</p><h3 id="Sobel-算子中使用-CustomDepth-还是-CustomStencil？"><a href="#Sobel-算子中使用-CustomDepth-还是-CustomStencil？" class="headerlink" title="Sobel 算子中使用 CustomDepth 还是 CustomStencil？"></a>Sobel 算子中使用 CustomDepth 还是 CustomStencil？</h3><p>虽然说上述截图都是使用 CustomStencil，但其实一开始我本意是想使用 CustomDepth 实现。主要差别见下（前者为 Depth，后者为 Stencil）：</p><p><img src="diff_depth.png" alt="image-20220108172521492"></p><p><img src="diff_stencil.png" alt="diff_stencil"></p><ul><li><p>用 CustomDepth 的好处在于其可以将<strong>重叠物体中每一个物体都描绘出边缘</strong>，因为其算出来的梯度距离是具有物理意义的，因此设置恰当的远/近梯度值，既可以区分出不同物体（因为不同物体如果挨得不太近，边缘处梯度值还是蛮大的）。而 CustomStencil 由于只是一个蒙版值，两个叠在一起的物体蒙版值是没有区别的，因此描边连成了一片。当然，重叠物体是否描绘边缘更多的还是美术方面的考量，需要根据项目美术风格来定。</p></li><li><p>用 CustomDepth 的麻烦之处就是要指定梯度范围，即在 [ClampMin, ClampMax] 范围内的值被映射为 Edge Mask [0, 1]，导致<strong>其描出来的边理论上是一个渐变</strong>，这在一个物体深度变化很大时（例如上图右侧大白球）比较明显。关于这点，我们可以用不同的映射曲线，例如 Smoothstep 来代替 Lerp：</p><p><img src="smoothstep.png" alt="smoothstep"></p><p>当然，两个不同物体边缘处的梯度一般情况下是会比一个物体内部梯度大很多的，因此我们可以通过<strong>将 ClampMax 设的很高</strong>来让物体内部的渐变变得不明显。当然这样做的坏处是<strong>重叠物体之间的描边会被减淡</strong>，因此还是要看美术的取舍，例如确定了场景中描边物体不会过大时，ClampMax 可以相对调小一点。</p></li><li><p>CustomDepth 一个最致命的问题，就是<strong>深度这个东西在移动平台和桌面端精度差很多</strong>，例如 Depth Buffer 格式（32/24/16bit），计算精度（全精度/半精度），是否启用 Reversed-Z（这点 UE4 倒是不用考虑，因为其设置了 <code>GL_ARB_clip_control</code>，但 Unity 则不会在 OpenGL 平台开启 Reversed-Z），导致很多参数在 PC 和手机上差别大相径庭，例如下面这两张图，在 PC 上使用 CustomDepth，ClampMax 值可以调到 100,000，而在移动平台该值高过 16,000 就没效果了（使用 OpenGL）。</p><p><img src="Screenshot_20220108-181112_3329236bee1bbacba1d22d113a1b46b2.jpg" alt="Screenshot_20220108-181112_3329236bee1bbacba1d22d113a1b46b2"></p><p><img src="Screenshot_20220108-181923_3329236bee1bbacba1d22d113a1b46b2.jpg" alt="Screenshot_20220108-181923_3329236bee1bbacba1d22d113a1b46b2"></p><p>因此为了统一效果，之后还是选用了 CustomStencil 来进行边缘检测。</p></li></ul><h3 id="移动平台后处理拿不到深度？"><a href="#移动平台后处理拿不到深度？" class="headerlink" title="移动平台后处理拿不到深度？"></a>移动平台后处理拿不到深度？</h3><p>如果我们在移动端使用默认的 SceneColorFormat，即 <code>PF_FloatRGBA</code> ，其每个像素占用 16x4=64 bit，在移动端带宽受限的情况下显得不是很划算，因此很多项目都改成了 <code>PF_FloatR11G11B10</code>，其是个 HDR 格式，但由于少了 Alpha 通道，而 UE4 又使用了这个 Alpha 通道给后处理材质做深度，因此<strong>当切换到 R11G11B10 以后，后处理就拿不到深度了。</strong></p><p>此时我们要做两件事：</p><ol><li><p><strong>Depth Buffer 在 Base Pass 结束后可能会被 Invalidate 掉</strong>（<code>glInvalidateFramebuffer</code>），即不让深度从片上缓存写回到内存，来节省移动设备的带宽。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MobileShadingRenderer.cpp:398</span></span><br><span class="line"><span class="comment">// InitViews()</span></span><br><span class="line">bKeepDepthContent = </span><br><span class="line">    bRequiresMultiPass || </span><br><span class="line">    bForceDepthResolve ||</span><br><span class="line">    bRequiresPixelProjectedPlanarRelfectionPass ||</span><br><span class="line">    bSeparateTranslucencyActive ||</span><br><span class="line">    Views[<span class="number">0</span>].bIsReflectionCapture ||</span><br><span class="line">    (bDeferredShading &amp;&amp; bPostProcessUsesSceneDepth) ||</span><br><span class="line">    bShouldRenderVelocities ||</span><br><span class="line">    bIsFullPrepassEnabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bKeepDepthContent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// store depth if post-processing/capture needs it</span></span><br><span class="line">    DepthTargetAction = EDepthStencilTargetActions::ClearDepthStencil_StoreDepthStencil;</span><br><span class="line">    <span class="comment">// FOpenGLDynamicRHI::RHIEndRenderPass 会触发 RHIDiscardRenderTargets，从而调用 FOpenGL::InvalidateFramebuffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此处看似可以直接拿来用的 <code>bPostProcessUsesSceneDepth</code> 竟然是给移动延迟渲染管线用的……</p></blockquote><p>此处我们可以通过<strong>直接设置 <code>r.Mobile.ForceDepthResolve</code> 为 1</strong> 来使得 <code>bKeepDepthContent</code> 永远为 <code>true</code>，这样 Depth Attachment 将不会被 Invalidated 了。当然我们也可以添加自己的 CVar。</p></li><li><p>解决了 C++ 侧，我们还得再改一下 Shader，因为后处理 Shader 里也默认深度从 <code>SceneColor.a</code> 中取得了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SceneTexturesCommon.ush:129</span><br><span class="line">float LookupDeviceZ( float2 ScreenUV )</span><br><span class="line">&#123;</span><br><span class="line">// ...</span><br><span class="line">#elif (POST_PROCESS_MATERIAL || POST_PROCESS_MATERIAL_MOBILE) &amp;&amp; !POST_PROCESS_AR_PASSTHROUGH</span><br><span class="line">#if MOBILE_DEFERRED_SHADING</span><br><span class="line">return Texture2DSample(MobileSceneTextures.SceneDepthTexture, MobileSceneTextures.SceneDepthTextureSampler, ScreenUV).r;</span><br><span class="line">#else</span><br><span class="line">// SceneDepth texture is not accessible during post-processing as we discard it at the end of mobile BasePass</span><br><span class="line">// instead fetch DeviceZ from SceneColor.A</span><br><span class="line">return Texture2DSample(MobileSceneTextures.SceneColorTexture, MobileSceneTextures.SceneColorTextureSampler, ScreenUV).a;  // !!</span><br><span class="line">#endif</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将用 <code>!!</code> 标记行改为直接从 SceneDepthTexture 场景纹理中采样即可，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return Texture2DSample(MobileSceneTextures.SceneDepthTexture, MobileSceneTextures.SceneDepthTextureSampler, ScreenUV).r;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Custom-Depth-性能问题？"><a href="#Custom-Depth-性能问题？" class="headerlink" title="Custom Depth 性能问题？"></a>Custom Depth 性能问题？</h3><p>除了上述的效果问题，我们用来实现描边高亮的 CustomDepth Pass 也有它自己的性能问题，一些是设计使然，一些则可能是为了确保兼容。<strong>此处仅仅先简单列举一些可能存在的问题</strong>，有时间我会再水一篇专门分析 Custom Depth 性能问题并试图去解决的文章，嘻嘻。</p><h4 id="遮挡剔除"><a href="#遮挡剔除" class="headerlink" title="遮挡剔除"></a>遮挡剔除</h4><p>在 Primitive 勾选上 CustomDepth 后，该 Primitive 的遮挡剔除将会失效（视锥剔除依然开启）。如下图所示：</p><p><img src="oc_no_customdepth.png" alt="oc_no_customdepth"></p><p><img src="oc_with_customdepth.png" alt="oc_with_customdepth"></p><h4 id="多余的-Depth-Stencil-RT"><a href="#多余的-Depth-Stencil-RT" class="headerlink" title="多余的 Depth / Stencil RT"></a>多余的 Depth / Stencil RT</h4><p>在移动端渲染器中，CustomDepth 输出了三张 Render Target：</p><ul><li>[R16_Float] MobileCustomDepth</li><li>[R8_UNORM] MobileCustomStencil</li><li>[D24S8] CustomDepth</li></ul><p><img src="rdc_rt.png" alt="image-20220108234727260"></p><p>其中 D24S8 的纹理最终被 Invalidate 掉了，剩下两张纹理被后处理使用。但理论上，我们可以做到<strong>只写入 Depth Attachment</strong>，在 OpenGL 中即体现为 <code>glDrawBuffer(GL_NONE)</code><a href="https://stackoverflow.com/questions/32956543/make-draw-call-in-opengl-that-only-touches-the-depth-buffer">（OpenGL ES 3.0 以上支持）</a>。</p><h4 id="CustomDepth-Pass-不使用-Instancing-绘制"><a href="#CustomDepth-Pass-不使用-Instancing-绘制" class="headerlink" title="CustomDepth Pass 不使用 Instancing 绘制"></a>CustomDepth Pass 不使用 Instancing 绘制</h4><p>在桌面端以及移动端打开 Mesh Auto-Instancing 的平台上，<strong>CustomDepth Pass 依然不会使用 Instancing 来绘制</strong>。但其实在 Custom Pass 中，对于包含同样 Depth-Stencil State 的物体（CustomStencil 的写入值实际上就在改变 DepthStencilState 的 StencilRef），如果 Mesh 还一致的话，<a href="https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Rendering/MeshDrawingPipeline/#drawcallmerging">应该可以触发 Instancing</a>。</p><blockquote><p>在使用 <code>OMSetDepthStencil</code> / <code>glStencilFunc</code> 只变更 Stencil Reference 时，是<strong>不会触发驱动更换/重编译 Pipeline (PSO) 的</strong>，因此一个 Draw Call 的成本不大，其实可以接受。这点也反映在 Vulkan 上，UE 使用的是 Dynamic State，即 <code>vkCmdSetStencilReference</code> 来改变该值。</p><p><img src="vk_dynamic_pipeline.png" alt="vk_dynamic_pipeline"></p></blockquote><h2 id="Part-4-后记"><a href="#Part-4-后记" class="headerlink" title="Part.4 后记"></a>Part.4 后记</h2><p>其实我一直自诩为一个引擎向游戏开发者，但仍然在实现一个简单的描边+遮挡高亮上栽了几跟头，也让我深深感受到了在现有商业引擎庞大框架体系中，一个看似简单的优化是多么“牵一发而动全身”。</p><p>关于之前提到的 CustomDepth 的优化问题，可能将在之后的博客文章中提到，但由于给手游优化一向不是我的菜，所以不知道得拖更多长时间了。</p><p>最后放上示例项目的 GitHub 链接：<a href="https://github.com/GavinKG/UE4-Multicolor-Outline-and-Silhouette">https://github.com/GavinKG/UE4-Multicolor-Outline-and-Silhouette</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;banner.jpg&quot; alt=&quot;banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;示例项目的 GitHub 链接：&lt;a href=&quot;https://github.com/GavinKG/UE4-Multicolor-Outline-and-Silhouette&quot;&gt;https://github.com/GavinKG/UE4-Multicolor-Outline-and-Silhouette&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 Unreal Engine 4.27。示例项目未改动引擎。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UE" scheme="https://gavinkg.github.io/blog/tags/UE/"/>
    
    <category term="UE4" scheme="https://gavinkg.github.io/blog/tags/UE4/"/>
    
    <category term="渲染" scheme="https://gavinkg.github.io/blog/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>离轴透视投影 (Off-axis Perspective Projection) 的应用——场景放大、超分辨率截图、镜面/传送门渲染</title>
    <link href="https://gavinkg.github.io/blog/%E7%A6%BB%E8%BD%B4%E9%80%8F%E8%A7%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://gavinkg.github.io/blog/%E7%A6%BB%E8%BD%B4%E9%80%8F%E8%A7%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</id>
    <published>2022-01-04T16:00:00.000Z</published>
    <updated>2022-03-22T04:12:49.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src="banner.jpg" alt="banner"></p><p>题图为游戏《A Plague Tale: Innocence》的女主 Amicia。这张截图是我使用 NVIDIA Ansel 超级分辨率功能截取得到的，该功能即使用了这篇文章介绍的内容：离轴透视投影。</p><span id="more"></span><p>使用 Unity 演示。</p><h2 id="Part-1-前言"><a href="#Part-1-前言" class="headerlink" title="Part.1 前言"></a>Part.1 前言</h2><p>前些天刚玩通一款独立游戏《笼中窥梦》，惊叹于作者塑造的精致箱庭世界以及开发团队之小的同时，作为 Game Designer，当然是对这款游戏中驱动玩法的，诸多打破常理的画面的渲染原理非常感兴趣，正好自己最近也在着手制作一些类传送门元素的关卡设计，于是提笔写下了这篇技术笔记分享给大家。</p><h2 id="Part-2-实现基础"><a href="#Part-2-实现基础" class="headerlink" title="Part.2 实现基础"></a>Part.2 实现基础</h2><p>还记得在引擎中调整摄像机的时候，我们都需要调节哪些参数吗？其实除了位置渲染这些信息（决定观察者坐标系），剩下的就是 FOV、横纵比和远近裁切平面了（不考虑物理摄像机）。FOV 决定着视野的宽阔程度，横纵比决定着屏幕比例，远近裁切平面之间的物体会被显示。这两大参数可以用来生成出我们再熟悉不过的投影矩阵（Projection Matrix，以 OpenGL 约定为例，不同图形 API 的约定差异可以参考<a href="https://gavinkg.github.io/ILearnVulkanFromScratch-CN/mdroot/%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2%20API%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB.html">我的这篇笔记</a>[5]）：</p><script type="math/tex; mode=display">\left[\begin{array}{cccc} { \dfrac{cot\dfrac{fovy}{2}}{aspect} } & 0 & 0 & 0 \\ 0 & { cot \dfrac{fovy}{2} } & 0 & 0 \\ 0 & 0 & -{\dfrac{f+n}{f-n}} & -{\dfrac{2fn}{f-n}}\\ 0 & 0 & -1& 0\\ \end{array}\right]</script><p>其中 <em>fovy</em> 代表纵向延展的 FOV 值，<em>aspect</em> 为横纵比（长/宽），<em>n</em> (near) 和 <em>f</em> (far) 分别代表了近平面和远平面到观察者的最短距离，其形成了一个平截头体，我们称为视锥（View Frustum）。其在图形库和引擎中也有对应的 API：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from https://github.com/g-truc/glm</span></span><br><span class="line"><span class="comment">// 4 params are needed: [FOV], [Aspect Ratio], [Near Plane], [Far Plane]</span></span><br><span class="line">glm::mat4 Projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">pi</span>&lt;<span class="type">float</span>&gt;() * <span class="number">0.25f</span>, <span class="number">4.0f</span> / <span class="number">3.0f</span>, <span class="number">0.1f</span>, <span class="number">100.f</span>);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://docs.unity3d.com/ScriptReference/Matrix4x4.Perspective.html</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Matrix4x4 <span class="title">Perspective</span>(<span class="params"><span class="built_in">float</span> fov, <span class="built_in">float</span> aspect, <span class="built_in">float</span> zNear, <span class="built_in">float</span> zFar</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PerspectiveMatrix.h:40 (UE 4.27.2)</span></span><br><span class="line"><span class="built_in">FPerspectiveMatrix</span>(<span class="type">float</span> HalfFOV, <span class="type">float</span> Width, <span class="type">float</span> Height, <span class="type">float</span> MinZ, <span class="type">float</span> MaxZ);</span><br></pre></td></tr></table></figure><p><img src="image-20211226224839906.png" alt="image-20211226224839906"></p><p>但其实我们一直在做一个假设，就是<strong>观察者位置投影到成像平面（近平面）的视点位置即为近平面中心点</strong>，一切的透视关系都按照屏幕中心进行“缩放”，如上图所示[1]。这确实没错，大多数情况下人眼都会看不出区别，我们也已经适应了屏幕成像的样子。但其实在很多情况下，<strong>观察者位置投影到成像平面的视点位置并不恰好是屏幕中心</strong>，因此看到的画面其实是不符合观察者虚拟位置近大远小的透视关系的（想象你从侧面看一张照片，你看到照片里的物体的样子会在生活中出现吗），这种情况如果希望依然维持正确的透视关系，我们需要同步视点中心到透视投影矩阵中，即产生<strong>离轴透视投影 (Off-axis Perspective Projection)</strong> ，如下图所示[1]</p><p><img src="image-20211226225641377.png" alt="image-20211226225641377"></p><p>其实通过两者产生的视锥体也能看出端倪：我们最常见的视锥体，近平面中心点到远平面中心点的连线是垂直于这两个平面的，但离轴投影则不会垂直。这种情况下我们就不能通过常见的 FOV 和横纵比来描述摄像机了。幸好这个投影矩阵也可以直接根据<strong>近平面上下左右四条边到观察者在近平面上的投影点的距离</strong>，加上远近平面距离观察者的最小距离来推导：</p><script type="math/tex; mode=display">\left[\begin{array}{cccc} { \dfrac{2n}{ r-l } } & 0 & { \dfrac{r + l} { r-l } } & 0 \\ 0 & { \dfrac{2n}{ t-b } } & { \dfrac{t + b}{ t-b } } & 0 \\ 0 & 0 & -{\dfrac{f+n}{f-n}} & -{\dfrac{2fn}{f-n}}\\ 0 & 0 & -1& 0\\ \end{array}\right]</script><blockquote><p> 复习一下：投影矩阵的推导其实非常简单，其需要做的就有三点：1. 让最终齐次坐标的 $w=-z$，供之后的透视除法使用，即最后一行的 -1；2. 将观察空间 z 值从 [n, f] 映射到 [-1, 1] 区间中；3. 将观察空间 x, y 也从 [l, r] 和 [b, t] 限制到 [-1, 1] 区间中。直接上图巩固记忆（OpenGL 约定）[3]：</p><p> <img src="image-20211226231046030.png" alt="image-20211226231046030"></p></blockquote><p>图形库和 Unity 引擎依然有对应的 API：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenGL builtin API</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">glFrustum</span><span class="params">(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unity</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Matrix4x4 <span class="title">Frustum</span>(<span class="params"><span class="built_in">float</span> left, <span class="built_in">float</span> right, <span class="built_in">float</span> bottom, <span class="built_in">float</span> top, <span class="built_in">float</span> zNear, <span class="built_in">float</span> zFar</span>)</span>;</span><br></pre></td></tr></table></figure><p>我们可以直接使用其提供的 API，或者手动构建一个矩阵（UE 暂时没找到；直接编码到矩阵时需注意不同平台和引擎的差别，例如图形 API 区别、是否使用 Reversed-Z 等等）设置为摄像机的投影矩阵。此时观察者位置在成像平面上的投影点即为新的“透视缩放点”，一切将以观察者位置（而不是成像平面中心）产生近大远小的透视关系。</p><h2 id="Part-3-应用"><a href="#Part-3-应用" class="headerlink" title="Part.3 应用"></a>Part.3 应用</h2><p>啰啰嗦嗦讲了那么多原理（其实都是现成的 API），下面来看看离轴透视投影到底能用在哪些地方吧：</p><h3 id="分块渲染：场景放大、屏幕阵列渲染和高分辨率截图"><a href="#分块渲染：场景放大、屏幕阵列渲染和高分辨率截图" class="headerlink" title="分块渲染：场景放大、屏幕阵列渲染和高分辨率截图"></a>分块渲染：场景放大、屏幕阵列渲染和高分辨率截图</h3><p>有些时候我们希望把自己制作的游戏画面截出一张高分辨率截图收藏起来，又或者我们想“矢量”放大场景中的某个部分，又或者我们在组建一个高分辨率屏幕阵列渲染一个视口，然而一台计算机的图形算力并不能撑住屏幕阵列的渲染。解决上述问题即为离轴透视的第一个用途：<strong>渲染一个“正常”视锥体的一个子视锥，即分块渲染</strong>。</p><blockquote><p>对于高分辨率截图来说，由于显卡存在着 2D Texture 的最大长宽限制（一般为 16384 像素，感兴趣的同学可以去看 DX12 中的 <code>D3D12_REQ_TEXTURE2D_U_OR_V_DIMENSION</code> 和 Vulkan 中的 <code>maxImageDimension2D</code>），截图分辨率不能无限大下去。在 UE4 高分辨率截图源码中也能看到，当截图分辨率超过上述限制（<code>GetMax2DTextureDimension</code> 方法）时，截图会失败。还有一个原因是，如果一次渲染超高分辨率，显存资源可能不够用（例如GBuffer），并且驱动可能会因为单个渲染任务耗费时间过长而重启设备。</p></blockquote><p>首先要清楚的是，我们并不能通过新建一个相机，改一改 FOV 并旋转它到新的角度达到渲染场景的某个部分，因为我们所有的子视锥的成像平面依然是一个……呃……平面，近平面远平面必须分别在同一个平面上，才能构建出原始视锥的子视锥。当然我们如果组建球面屏幕的话这么做是可以的，即让每一块屏幕渲染球面的一个立体角。</p><p>子视锥的构建其实很简单：在近平面和远平面上都切出位置比例相同的矩形，对应点连接起来构成新的子视锥，如下图所示。此时如果矩形中心不恰好是远近平面中心的话，就满足了上述离轴透视的条件：观察者在近平面投影点不是新的近平面矩形的中心点，毕竟观察者的投影点没有变化，即<strong>我依然希望透视关系根据观察者位置进行近大远小</strong>。此时虽然场景被放大了，但透视关系没有变，就像在图片查看器中放大一张图一样。</p><p><img src="scenemag-zoom-preview.png" alt="scenemag-zoom-preview"></p><p><img src="scenemag-zoom-frustum.png" alt="scenemag-zoom-frustum"></p><p>我们可以直接根据偏移位置计算得到新的近平面矩形上下左右四条边到投影点的距离，代码可以参考我做的一个场景放大器 Unity Demo 工程：<a href="https://github.com/GavinKG/SceneMagnifier。">https://github.com/GavinKG/SceneMagnifier。</a></p><p><img src="https://github.com/GavinKG/SceneMagnifier/raw/master/banner.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range from (-1, -1) to (1, 1) inclusive, with (-1, -1) being screen&#x27;s lower-left, and (1, 1) being screen&#x27;s upper-right</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMagnifyRegion</span><span class="params">(<span class="type">float</span> xmin, <span class="type">float</span> ymin, <span class="type">float</span> xmax, <span class="type">float</span> ymax)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Retrive camera properties</span></span><br><span class="line">    <span class="type">float</span> n = camera.nearClipPlane;</span><br><span class="line">    <span class="type">float</span> f = camera.farClipPlane;</span><br><span class="line">    <span class="type">float</span> fovy = camera.fieldOfView; <span class="comment">// in degrees, uses verticle fov (fovy)</span></span><br><span class="line">    <span class="type">float</span> aspect = camera.aspect; <span class="comment">// width / height</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate l, r, b, t</span></span><br><span class="line">    <span class="type">float</span> ogT = Mathf.<span class="built_in">Tan</span>(fovy / <span class="number">2f</span> * Mathf.Deg2Rad) * n;</span><br><span class="line">    <span class="type">float</span> ogR = ogT * aspect;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> l = ogR * xmin;</span><br><span class="line">    <span class="type">float</span> r = ogR * xmax;</span><br><span class="line">    <span class="type">float</span> b = ogT * ymin;</span><br><span class="line">    <span class="type">float</span> t = ogT * ymax;</span><br><span class="line"></span><br><span class="line">    Matrix4x4 persp = Matrix4x4.<span class="built_in">Frustum</span>(l, r, b, t, n, f);</span><br><span class="line">    camera.projectionMatrix = persp;</span><br><span class="line">    camera.cullingMatrix = persp * camera.worldToCameraMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接上视频：</p><p><a href="Scene-Magnifier-Showcase-x264.mp4">&gt;&gt; 视频链接 - 场景放大器效果 &lt;&lt;</a></p><p><a href="Scene-Magnifier-Visualize-x264.mp4">&gt;&gt; 视频链接 - 场景放大器原理 &lt;&lt;</a></p><p>有了这些代码，做高分辨率截图就很容易了。我们可以将屏幕等分为 m x n 块，对于每块分别渲染保存为位图，再使用外部软件将其合并，避开一次不能渲染太大尺寸纹理的硬件限制。</p><blockquote><p>当然这么做有一点不能避开的是后处理。由于一般情况下，一些后处理根据全屏覆盖的四边形UV进行计算（例如暗角），因此需要加以修改从而使得此类后处理应用于整个阵列而不是每个分块。一些需要采样临近像素，甚至在整个屏幕空间做 Ray Marching 求交的效果，可能都会失效（例如 SSR 在分块接缝处可能会有明显的断裂）。在工程中我们可以将每个分块些许增大，并后期剪裁，多留一些屏幕空间信息给屏幕空间算法，或者分块时让两块之间相互重叠，后期在分块重叠部分中渐变过渡（NVIDIA Ansel 采取的方案）。但这都算不上完美的解决方案。</p></blockquote><p>同理，对于屏幕阵列渲染来说，我们可以将每一块/几块屏幕交给一台计算机进行渲染，并使用离轴透视进行相机投影矩阵的配置。可以看到，上述代码对相机的 culling matrix 也进行了设置，因此每台计算机在渲染时，输送进 GPU 的图元也是<strong>经过良好的视锥剔除的</strong>。</p><h3 id="镜面-传送门渲染新方案（使用-Render-Texture）"><a href="#镜面-传送门渲染新方案（使用-Render-Texture）" class="headerlink" title="镜面/传送门渲染新方案（使用 Render Texture）"></a>镜面/传送门渲染新方案（使用 Render Texture）</h3><p><img src="portal.png" alt="portal"></p><p>游戏中经常会有全反射的镜子，以及传送门元素的渲染，例如大名鼎鼎的《Portal》系列。镜面/传送门渲染的方法很多，其中<strong>使用 Stencil Buffer</strong> 标记传送门区域，然后开启 Stencil Test 渲染镜面/传送门的方法比较流行，因为其直接在屏幕空间进行传送门内部的渲染，能够做到 pixel-perfect（下称“Stencil 方案”）。类似的也有<strong>让反射/传送门相机渲染出一张全屏的纹理</strong>，然后在反射物体着色时，片元着色器中<strong>直接使用屏幕空间坐标采样那张全屏纹理</strong>（下称“全屏 RT 方案”）。</p><p>我这里介绍的是另一种方法，即同样使用 Render Texture，<strong>但直接将该纹理直接应用于传送门的材质中</strong>（即“贴在物体上”）采样输出（下称“本方案”）。</p><p>当然，本方案远没有想象的那么简单。除了需要将传送门的相机摆放在正确的位置外，我们也需要考虑下面几个问题：</p><ol><li>由于没有 Stencil Mask 辅助标记屏幕空间的呈现区域，因此 RT 摄像机渲染出来的区域<strong>必须和传送门显示的完全一致</strong>。否则即使不在乎渲染浪费，我们也不知道怎么计算出该显示的区域。</li><li><strong>RT 摄像机的近平面必须为传送门所在平面</strong>，不然会被近平面裁切，导致渲染不全。</li><li>本方案渲染出的 Render Texture <strong>将会呈现在传送门物体切线空间中</strong>，而并不直接是屏幕空间中。</li></ol><p>如果把主摄像机（透视投影）当成上例中人眼，传送门物体当成上例中显示器的话，此时在主摄像机（透视投影）倾斜着看传送门物体，就能够类比人眼倾斜着看屏幕的情况，<strong>可以直接用上述离轴透视投影矩阵来纠正</strong>，解决了第三点。同时，采用离轴透视就意味着把传送门平面当成成像平面，因此传送门摄像机的前方向就要与目标传送门垂直，并且旋转和目标传送门一致，此时只需要调整近平面距离即可让近平面矩形和传送门显示矩形完全一致，解决了第二点，再通过数学运算算出摄像机最终位置，让其成像恰好为传送门需要显示出来的即可。如下图所示：</p><p><img src="portal-unity-visualize.jpg" alt="portal-unity-visualize"></p><blockquote><p>这里也顺带说一下，如果使用 Stencil 方案和全屏幕 RT 方案，同样可以使用 Oblique Near-plane Projection 的方法，将近平面变成目标传送门平面，来避免被后墙遮挡和近处被裁切的现象发生。Unity 直接提供了 <code>Camera.CalculateObliqueMatrix</code> 方法，可以直接设置一个自定义近平面。</p></blockquote><p>同样，这里给出计算摄像机位置，旋转，以及离轴透视投影矩阵的核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetupPortalCamera</span><span class="params">(PortalConnectionInfo connectionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3 camPos = ViewCamera.transform.position;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find target camera&#x27;s rotation (same as target portal)</span></span><br><span class="line">    Quaternion targetCamRot = connectionInfo.targetPortal.transform.rotation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find target camera&#x27;s position</span></span><br><span class="line">    Vector3 camPosLS = connectionInfo.sourcePortal.transform.<span class="built_in">InverseTransformPoint</span>(camPos);</span><br><span class="line">    camPosLS.z *= <span class="number">-1</span>; <span class="comment">// mirror-like</span></span><br><span class="line">    Vector3 targetCamPos = connectionInfo.targetPortal.transform.<span class="built_in">TransformPoint</span>(camPosLS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Figure out perspective projection&#x27;s center point on near plane</span></span><br><span class="line">    Plane nearPlane = <span class="keyword">new</span> <span class="built_in">Plane</span>(connectionInfo.targetPortal.FacingDirection, connectionInfo.targetPortal.transform.position); <span class="comment">// the target portal&#x27;s sitting plane, therefore becoming portal camera&#x27;s near plane</span></span><br><span class="line">    Vector3 centerPointWS = nearPlane.<span class="built_in">ClosestPointOnPlane</span>(targetCamPos); <span class="comment">// find the center point</span></span><br><span class="line">    Vector3 centerPointLS = connectionInfo.targetPortal.transform.<span class="built_in">InverseTransformPoint</span>(centerPointWS); <span class="comment">// x, y should be the offset for the frustum</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate the off-axis projection matrix</span></span><br><span class="line">    <span class="type">float</span> far = ViewCamera.farClipPlane;</span><br><span class="line">    <span class="type">float</span> near = Vector3.<span class="built_in">Distance</span>(centerPointWS, targetCamPos);</span><br><span class="line">    <span class="type">float</span> left = connectionInfo.sourcePortal.LocalUpperLeftCorner.x - centerPointLS.x;</span><br><span class="line">    <span class="type">float</span> right = connectionInfo.sourcePortal.LocalUpperRightCorner.x - centerPointLS.x;</span><br><span class="line">    <span class="type">float</span> top = connectionInfo.sourcePortal.LocalUpperLeftCorner.y - centerPointLS.y;</span><br><span class="line">    <span class="type">float</span> bottom = connectionInfo.sourcePortal.LocalLowerLeftCorner.y - centerPointLS.y;</span><br><span class="line">    Matrix4x4 proj = Matrix4x4.<span class="built_in">Frustum</span>(left, right, bottom, top, near, far);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply to the camera object</span></span><br><span class="line">    connectionInfo.cameraObject.transform.position = targetCamPos;</span><br><span class="line">    connectionInfo.cameraObject.transform.rotation = targetCamRot;</span><br><span class="line">    Camera portalCamera = connectionInfo.cameraObject.<span class="built_in">GetComponent</span>&lt;Camera&gt;();</span><br><span class="line">    portalCamera.projectionMatrix = proj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let Unity draw camera&#x27;s frustum correctly...</span></span><br><span class="line">    portalCamera.nearClipPlane = near;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Portal culling</span></span><br><span class="line">    portalCamera.cullingMatrix = proj * portalCamera.worldToCameraMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Shader 中采样纹理时，别忘了做水平镜面翻转，类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float4 frag(Varyings IN) : SV_TARGET</span><br><span class="line">&#123;</span><br><span class="line">    IN.uv.x  = 1 - IN.uv.x; // mirror-invert</span><br><span class="line">    return SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，该矩阵同样作为了传送门摄像机的 Culling Matrix。由于传送门摄像机的视锥必须刚刚好设成传送门的渲染范围，因此<strong>该矩阵作为剔除矩阵进行视锥体剔除相当高效</strong>，在使用其它方案渲染镜面和传送门时也可以用该矩阵进行视锥剔除。</p><p>关于传送门切线空间计算和摆放等与渲染无关的细节将不再此处赘述，可以前往 <a href="https://github.com/GavinKG/Portal-Rendering-Demo-using-Off-Axis-Perspective-Projection">https://github.com/GavinKG/Portal-Rendering-Demo-using-Off-Axis-Perspective-Projection</a> 下载示例工程和源码，其包含一个使用本方案的 FPS 传送门的摆放和渲染实现。直接上视频：</p><p>（前者为场景传送门演示，后者为原理）</p><p><a href="Portal-Unity-Showcase-x264.mp4">&gt;&gt; 视频链接 - 传送门效果 &lt;&lt;</a></p><p><a href="Portal-Unity-Visualize-x264.mp4">&gt;&gt; 视频链接 - 传送门渲染原理 &lt;&lt;</a></p><blockquote><p>其实本方案相较于 Stencil 方案来渲染传送门/镜面反射存在诸多劣势，但也有其无可替代的地方。本方案中 RT 由于应用于传送门模型表面，从纹素到像素颜色信息注定会被插值，因此无法做到 pixel-perfect。同时由于 RT 每帧做 Runtime Mipmap 生成的开销比较大，如果不存在 mipmaps 的话，无法做到纹理的三线性/各向异性过滤，违反了采样定理，在极端角度上看传送门效果会非常惨烈。但全屏 RT 方案和本方案首先<strong>实现简单</strong>（这点在实际的商业项目中真的很重要），在现有的支持多相机的渲染管线下（例如 Unity 和 UE 自带的渲染管线），不用改管线就可以做到完美的渲染实现（Stencil 方案在做递归渲染传送门时可能需要配合管线的修改以实现最大性能），并且可以很方便低降分辨率。同时，由于 RT 最终是被传送门模型当成一张普通的纹理进行采样，因此那些<strong>使用 UV 的特效依然可以使用在传送门上</strong>，例如传送门的扭曲、扰动（类似水面的反射渲染）效果。全屏 RT 方案和本方案<strong>渲染传送门前面的半透明物体也不用多做考虑</strong>，然而使用 Stencil 方案，在渲染完传送门内部之后才能够渲染外部的透明物体，依然需要渲染管线本身的支持。甚至在实际项目中，<strong>有些时候 Stencil Buffer 被用来做其它工作了</strong>，在宝贵的 GBuffer 里单独为镜面开一张 Stencil 也不划算，因此使用 RT 则成为了最优解。</p><p>全屏 RT 方案和 Stencil 方案原理没什么本质上的区别，也具有上述使用 RT 的一些优势，但可能存在浪费渲染的情况，因此一般用于大型水体、大型镜面和地面假反光的渲染上。此处如果使用 RT 渲染小型镜面、传送门时使用本文实现方法性能会更佳。</p></blockquote><h2 id="Part-4-后记"><a href="#Part-4-后记" class="headerlink" title="Part.4 后记"></a>Part.4 后记</h2><p>当然，离轴透视投影的应用还有很多，例如 VR 双眼的离轴透视矫正，以及 AR 中使用离轴透视投影（类似于传送门渲染）[4] 等。离轴透视投影本身并不难，但用好它能够创造出很多有意思的应用场景。找到这些点子并成功应用在游戏设计中也会是 Game Designer 工作中最开心的地方之一吧。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p>图出处：</p><p><a href="http://160592857366.free.fr/joe/ebooks/ShareData/Generalized%20Perspective%20Projection.pdf">http://160592857366.free.fr/joe/ebooks/ShareData/Generalized%20Perspective%20Projection.pdf</a></p></li><li><p>OpenGL 中的 <code>glFrustum</code> 方法：</p><p><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/opengl/glfrustum">https://docs.microsoft.com/en-us/windows/win32/opengl/glfrustum</a></p></li><li><p>Scratchapixel 推导透视矩阵，权当复习一下：</p><p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix">https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix</a></p><p><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix">https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix</a></p></li><li><p>AR 中的应用，这个确实太炫酷了：</p><p><a href="https://medium.com/@michel.brisis/off-axis-projection-in-unity-1572d826541e">https://medium.com/@michel.brisis/off-axis-projection-in-unity-1572d826541e</a></p></li><li><p>不同图形 API 之间约定区别（OpenGL/Direct3D/Vulkan/Metal）：</p><p><a href="https://gavinkg.github.io/ILearnVulkanFromScratch-CN/mdroot/%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2%20API%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB.html">https://gavinkg.github.io/ILearnVulkanFromScratch-CN/mdroot/%E6%A6%82%E5%BF%B5%E6%B1%87%E6%80%BB/%E4%B8%8D%E5%90%8C%E5%9B%BE%E5%BD%A2%20API%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB.html</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;banner.jpg&quot; alt=&quot;banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;题图为游戏《A Plague Tale: Innocence》的女主 Amicia。这张截图是我使用 NVIDIA Ansel 超级分辨率功能截取得到的，该功能即使用了这篇文章介绍的内容：离轴透视投影。&lt;/p&gt;</summary>
    
    
    
    
    <category term="渲染" scheme="https://gavinkg.github.io/blog/tags/%E6%B8%B2%E6%9F%93/"/>
    
    <category term="Unity" scheme="https://gavinkg.github.io/blog/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>如何快速处理 PS5 录制的 HDR 视频素材并剪辑</title>
    <link href="https://gavinkg.github.io/blog/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E5%B9%B6%E5%89%AA%E8%BE%91%20PS5%20%E5%86%85%E5%BD%95%E8%A7%86%E9%A2%91%E7%B4%A0%E6%9D%90/"/>
    <id>https://gavinkg.github.io/blog/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E5%B9%B6%E5%89%AA%E8%BE%91%20PS5%20%E5%86%85%E5%BD%95%E8%A7%86%E9%A2%91%E7%B4%A0%E6%9D%90/</id>
    <published>2021-09-12T16:00:00.000Z</published>
    <updated>2022-03-22T03:07:45.093Z</updated>
    
    <content type="html"><![CDATA[<p><img src="banner.png" alt=""></p><span id="more"></span><p>PS5 的录屏功能相较 PS4 有很大提升：支持最高 4K / 60FPS / HDR 视频录制，奖杯视频录制，以及最高 1080p / 60FPS / HDR 的回放。为了支持这些高级特性，<strong>PS5 引入了对 WebM 容器，VP9 视频格式和 Opus 音频格式的支持，用来增加画质，同时减少存储空间。</strong></p><p>由于在 PS5 中只能使用上述新格式来录制高规格视频，导致后期如果想剪辑游戏视频时，剪辑软件的兼容性就会成为一大问题：对于回放来说，主流的播放器都能够很好的解码录制出来的视频，但对于剪辑来说，<strong>不经过处理的原始视频几乎不被主流视频剪辑软件识别或正常处理</strong>：</p><ul><li>Premiere Pro：最新版依然不支持 VP9。WebM 官网推荐使用一个<a href="https://www.fnordware.com/WebM/">第三方 Premiere 插件</a>来让 Premiere 支持 WebM 容器和 VP9 / Opus 解码器，但是插件的最后更新日期是 2017 年，因此该插件完全不支持硬件解码，在处理 PS5 录制出来的 4K / 60FPS 视频时，Premiere 几乎卡死。</li><li>DaVinci Resolve：最新版支持 VP9，但不支持 Opus 解码和 WebM 容器。<a href="https://documents.blackmagicdesign.com/SupportNotes/DaVinci_Resolve_16_Supported_Codec_List.pdf">Resolve 要求 VP9 视频流必须封装在 MOV 容器中</a>。</li><li>剪映专业版：作为最受欢迎的轻量级视频编辑软件，其支持硬件解码回放 PS5 录制的视频素材，但和原始视频相比有很严重的色差，通过其简单的调色面板也完全无法调整回原始视频的颜色。</li></ul><p>解决办法当然也是有的，例如使用采集卡，或者用 Handbrake 或 FFMPEG 等工具预先生成代理然后再进入剪辑软件，但这种方法势必会造成视频二压，或是转换后大小爆表（例如使用 ProRes），或是时间过长，并且如果使用最老牌的 H.264 作为代理格式，由于我们需要位深为 10-bit，其生成的文件（Hi10P）也不能被硬解码。</p><p>这里推荐一种快速且高质量的解决办法：<strong>由于 DaVinci Resolve 支持 VP9，因此我们可以完全跳过视频的转码过程，而只需要将容器由 WebM 改为其指定的 MOV，并且转码音频（例如到 AAC）即可。</strong>DaVinci 的基础版<strong>完全免费</strong>，对于一般的剪辑调色工作来说完全可以胜任，并且完美支持 HDR 工作流。</p><hr><p><strong>使用 DaVinci Resolve 剪辑 PS5 录制游戏视频步骤如下：</strong></p><ol><li><p>用 FFMPEG 更换容器</p><p>首先使用 FFMPEG 更换容器并转码音频。如果不显式指定容器，直接使用 <code>.mov</code> 后缀作为输出文件名时，FFMPEG 会报 <code>vp9 only supported in MP4</code> 错误。这是因为在 Apple MOV 容器的规范中并没有提到可以使用 VP9 作为视频流。这就奇怪了：官方和 FFMPEG 都说不能将 VP9 封装在 MOV 容器中，但 Resolve 却只能识别在 MOV 容器中的 VP9 视频流。因此我们用一种 Hack 的方法来骗过所有人：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.webm -f mp4 -vcodec copy -c:a aac -b:a 384k output.mov</span><br></pre></td></tr></table></figure><p>通过 <code>-f</code> 参数来强制指定我们使用 MP4 的封装方法来得到 MOV 文件。注意，这和直接输出 MP4（MP4 支持 VP9）然后改后缀名还不一样。如果想对文件夹中的所有录屏文件都应用上述转换逻辑，可以使用下面的 shell 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *.webm; <span class="keyword">do</span> ffmpeg -i <span class="string">&quot;<span class="variable">$i</span>&quot;</span> -f mp4 -vcodec copy -c:a aac -b:a 384k <span class="string">&quot;<span class="subst">$(basename <span class="string">&quot;<span class="variable">$i</span>&quot;</span> .webm)</span>&quot;</span>.mov; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这样我们几乎不会花费任何时间，并且只是付出了和原始文件相同大小的存储空间就得到了能够被 DaVinci Resolve 支持并硬解码的视频文件。</p></li><li><p>调整项目设置</p><p>DaVinci Resolve 默认工作在 SDR 流程（即 Rec.709）中。为了让 DaVinci Resolve 切换到 HDR 工作流，需要在项目设置（Project Settings）中更改色彩管理的设置，如下图所示：</p><p><img src="1.png" alt="image"></p><p>PS5 录屏文件的色彩空间为 BT.2020，传输方程为PQ，使用 10-bit 进行编码，正好可以和我们的配置对应上。</p></li><li><p>调整导出设置</p><p>在使用交付面板导出时，我们也需要选择正确的导出格式才能够生成最终的 HDR 视频。</p><ul><li><p>对于使用未付费版本的同学来说，由于并没有 H.265 编码授权，建议使用 DNxHR 格式作为中间格式，然后通过 Handbrake 或 FFMPEG 等工具转换为所需要的 H.265 等格式进行上传。此处建议选择 DNxHR HQX 10-bit，以兼顾大小和画质。</p><p><img src="2.png" alt="image-20210913222329147"></p></li><li><p>对于已购买 Studio 的同学来说，建议直接使用 H.265 (HEVC) 编码。注意一定要在 Encoding Profile 一栏中选择 Main10，即使用 10-bit 位深，来减小 HDR 下的色彩断层。</p><p><img src="3.png" alt="image-20210913222027413"></p></li></ul><p>导出以后就可以愉快的上传到 B 站和 Youtube 了。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;banner.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="PS5" scheme="https://gavinkg.github.io/blog/tags/PS5/"/>
    
    <category term="视频剪辑" scheme="https://gavinkg.github.io/blog/tags/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91/"/>
    
  </entry>
  
</feed>
